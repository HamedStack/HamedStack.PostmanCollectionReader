// <auto-generated />

#nullable enable
#pragma warning disable CS8618
#pragma warning disable CS8601
#pragma warning disable CS8603
#pragma warning disable CS1591

namespace HamedStack.PostmanCollectionV1_0_0
{
    using System;
    using System.Collections.Generic;

    using System.Text.Json;
    using System.Text.Json.Serialization;
    using System.Globalization;

    public partial class PostmanCollection1_0_0
    {
        [JsonPropertyName("auth")]
        public PostmanAuth Auth { get; set; }

        /// <summary>
        /// Provide a long description of this collection using this field. This field supports
        /// markdown syntax to better format the description.
        /// </summary>
        [JsonPropertyName("description")]
        public string Description { get; set; }

        [JsonPropertyName("events")]
        public PostmanEvent[] Events { get; set; }

        /// <summary>
        /// Folders are the way to go if you want to group your requests and to keep things
        /// organised. Folders can also be useful in sequentially requesting a part of the entire
        /// collection by using [Postman Collection
        /// Runner](https://www.getpostman.com/docs/jetpacks_running_collections) or
        /// [Newman](https://github.com/postmanlabs/newman) on a particular folder.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("folders")]
        public PostmanFolder[] Folders { get; set; }

        /// <summary>
        /// The folders order array ensures that your requests and folders don't randomly get
        /// shuffled up. It holds a sequence of
        /// [UUIDs](https://en.wikipedia.org/wiki/Universally_unique_identifier) corresponding to
        /// folders and requests.
        /// *Note that if a folder ID or a request ID (if the request is not already part of a
        /// folder) is not included in the order array, the request or the folder will not show up in
        /// the collection.*
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("folders_order")]
        public string[] FoldersOrder { get; set; }

        /// <summary>
        /// Every collection is identified by the unique value of this field. The value of this field
        /// is usually easiest to generate using a
        /// [UID](https://tools.ietf.org/html/rfc4122#section-4.4%29) generator function. If you
        /// already have a collection, it is recommended that you maintain the same id since changing
        /// the id usually implies that this is a different collection than it was originally.
        /// </summary>
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// A collection's friendly name is defined by this field. You would want to set this field
        /// to a value that would allow you to easily identify this collection among a bunch of other
        /// collections, as such outlining its usage or content.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// The order array ensures that your requests and folders don't randomly get shuffled up. It
        /// holds a sequence of [UUIDs](https://en.wikipedia.org/wiki/Universally_unique_identifier)
        /// corresponding to folders and requests.
        /// *Note that if a folder ID or a request ID (if the request is not already part of a
        /// folder) is not included in the order array, the request or the folder will not show up in
        /// the collection.*
        /// </summary>
        [JsonPropertyName("order")]
        public string[] Order { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("protocolProfileBehavior")]
        public Dictionary<string, object> ProtocolProfileBehavior { get; set; }

        [JsonPropertyName("requests")]
        public PostmanRequest[] Requests { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("timestamp")]
        public double? Timestamp { get; set; }

        [JsonPropertyName("variables")]
        public PostmanVariable[] Variables { get; set; }
    }

    /// <summary>
    /// Represents authentication helpers provided by Postman
    /// </summary>
    public partial class PostmanAuth
    {
        /// <summary>
        /// The attributes for API Key Authentication
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("apikey")]
        public PostmanApikeyElement[] Apikey { get; set; }

        /// <summary>
        /// The attributes for [AWS
        /// Auth](http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html).
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("awsv4")]
        public PostmanApikeyElement[] Awsv4 { get; set; }

        /// <summary>
        /// The attributes for [Basic
        /// Authentication](https://en.wikipedia.org/wiki/Basic_access_authentication).
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("basic")]
        public PostmanApikeyElement[] Basic { get; set; }

        /// <summary>
        /// The helper attributes for [Bearer Token
        /// Authentication](https://tools.ietf.org/html/rfc6750)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("bearer")]
        public PostmanApikeyElement[] Bearer { get; set; }

        /// <summary>
        /// The attributes for [Digest
        /// Authentication](https://en.wikipedia.org/wiki/Digest_access_authentication).
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("digest")]
        public PostmanApikeyElement[] Digest { get; set; }

        /// <summary>
        /// The attributes for [Akamai EdgeGrid
        /// Authentication](https://developer.akamai.com/legacy/introduction/Client_Auth.html).
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("edgegrid")]
        public PostmanApikeyElement[] Edgegrid { get; set; }

        /// <summary>
        /// The attributes for [Hawk Authentication](https://github.com/hueniverse/hawk)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("hawk")]
        public PostmanApikeyElement[] Hawk { get; set; }

        [JsonPropertyName("noauth")]
        public object Noauth { get; set; }

        /// <summary>
        /// The attributes for [NTLM
        /// Authentication](https://msdn.microsoft.com/en-us/library/cc237488.aspx)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("ntlm")]
        public PostmanApikeyElement[] Ntlm { get; set; }

        /// <summary>
        /// The attributes for [OAuth2](https://oauth.net/1/)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("oauth1")]
        public PostmanApikeyElement[] Oauth1 { get; set; }

        /// <summary>
        /// Helper attributes for [OAuth2](https://oauth.net/2/)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("oauth2")]
        public PostmanApikeyElement[] Oauth2 { get; set; }

        [JsonPropertyName("type")]
        public PostmanAuthType Type { get; set; }
    }

    /// <summary>
    /// Represents an attribute for any authorization method provided by Postman. For example
    /// `username` and `password` are set as auth attributes for Basic Authentication method.
    /// </summary>
    public partial class PostmanApikeyElement
    {
        [JsonPropertyName("key")]
        public string Key { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public string Type { get; set; }

        [JsonPropertyName("value")]
        public object Value { get; set; }
    }

    /// <summary>
    /// Defines a script associated with an associated event name
    /// </summary>
    public partial class PostmanEvent
    {
        /// <summary>
        /// Indicates whether the event is disabled. If absent, the event is assumed to be enabled.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("disabled")]
        public bool? Disabled { get; set; }

        /// <summary>
        /// A unique identifier for the enclosing event.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Can be set to `test` or `prerequest` for test scripts or pre-request scripts respectively.
        /// </summary>
        [JsonPropertyName("listen")]
        public string Listen { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("script")]
        public PostmanScript Script { get; set; }
    }

    /// <summary>
    /// A script is a snippet of Javascript code that can be used to to perform setup or teardown
    /// operations on a particular response.
    /// </summary>
    public partial class PostmanScript
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("exec")]
        public PostmanHost? Exec { get; set; }

        /// <summary>
        /// A unique, user defined identifier that can  be used to refer to this script from requests.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Script name
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("name")]
        public string Name { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("src")]
        public PostmanUrl? Src { get; set; }

        /// <summary>
        /// Type of the script. E.g: 'text/javascript'
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public string Type { get; set; }
    }

    public partial class PostmanUrlClass
    {
        /// <summary>
        /// Contains the URL fragment (if any). Usually this is not transmitted over the network, but
        /// it could be useful to store this in some cases.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("hash")]
        public string Hash { get; set; }

        /// <summary>
        /// The host for the URL, E.g: api.yourdomain.com. Can be stored as a string or as an array
        /// of strings.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("host")]
        public PostmanHost? Host { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("path")]
        public PostmanUrlPath? Path { get; set; }

        /// <summary>
        /// The port number present in this URL. An empty value implies 80/443 depending on whether
        /// the protocol field contains http/https.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("port")]
        public string Port { get; set; }

        /// <summary>
        /// The protocol associated with the request, E.g: 'http'
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("protocol")]
        public string Protocol { get; set; }

        /// <summary>
        /// An array of QueryParams, which is basically the query string part of the URL, parsed into
        /// separate variables
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("query")]
        public PostmanQueryParam[] Query { get; set; }

        /// <summary>
        /// The string representation of the request URL, including the protocol, host, path, hash,
        /// query parameter(s) and path variable(s).
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("raw")]
        public string Raw { get; set; }

        /// <summary>
        /// Postman supports path variables with the syntax `/path/:variableName/to/somewhere`. These
        /// variables are stored in this field.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("variable")]
        public PostmanVariable[] Variable { get; set; }
    }

    public partial class PostmanPathClass
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public string Type { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("value")]
        public string Value { get; set; }
    }

    public partial class PostmanQueryParam
    {
        [JsonPropertyName("description")]
        public PostmanDescriptionUnion? Description { get; set; }

        /// <summary>
        /// If set to true, the current query parameter will not be sent with the request.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("disabled")]
        public bool? Disabled { get; set; }

        [JsonPropertyName("key")]
        public string Key { get; set; }

        [JsonPropertyName("value")]
        public string Value { get; set; }
    }

    public partial class PostmanDescription
    {
        /// <summary>
        /// The content of the description goes here, as a raw string.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("content")]
        public string Content { get; set; }

        /// <summary>
        /// Holds the mime type of the raw description content. E.g: 'text/markdown' or 'text/html'.
        /// The type is used to correctly render the description when generating documentation, or in
        /// the Postman app.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public string Type { get; set; }

        /// <summary>
        /// Description can have versions associated with it, which should be put in this property.
        /// </summary>
        [JsonPropertyName("version")]
        public object Version { get; set; }
    }

    /// <summary>
    /// Collection variables allow you to define a set of variables, that are a *part of the
    /// collection*, as opposed to environments, which are separate entities.
    /// *Note: Collection variables must not contain any sensitive information.*
    ///
    /// Using variables in your Postman requests eliminates the need to duplicate requests, which
    /// can save a lot of time. Variables can be defined, and referenced to from any part of a
    /// request.
    /// </summary>
    public partial class PostmanVariable
    {
        [JsonPropertyName("description")]
        public PostmanDescriptionUnion? Description { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("disabled")]
        public bool? Disabled { get; set; }

        /// <summary>
        /// A variable ID is a unique user-defined value that identifies the variable within a
        /// collection. In traditional terms, this would be a variable name.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// A variable key is a human friendly value that identifies the variable within a
        /// collection. In traditional terms, this would be a variable name.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("key")]
        public string Key { get; set; }

        /// <summary>
        /// Variable name
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// When set to true, indicates that this variable has been set by Postman
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("system")]
        public bool? System { get; set; }

        /// <summary>
        /// A variable may have multiple types. This field specifies the type of the variable.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public PostmanVariableType? Type { get; set; }

        /// <summary>
        /// The value that a variable holds in this collection. Ultimately, the variables will be
        /// replaced by this value, when say running a set of requests from a collection
        /// </summary>
        [JsonPropertyName("value")]
        public object Value { get; set; }
    }

    /// <summary>
    /// One of the primary goals of Postman is to organize the development of APIs. To this end,
    /// it is necessary to be able to group requests together. This can be achived using
    /// 'Folders'. A folder just is an ordered set of requests.
    /// </summary>
    public partial class PostmanFolder
    {
        [JsonPropertyName("auth")]
        public PostmanAuth Auth { get; set; }

        /// <summary>
        /// Postman folders are always a part of a collection. That collection's unique ID (which is
        /// a [UUID](https://en.wikipedia.org/wiki/Globally_unique_identifier)) is stored in this
        /// field.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("collection")]
        public string Collection { get; set; }

        /// <summary>
        /// Postman folders are always a part of a collection. That collection's unique ID (which is
        /// a [UUID](https://en.wikipedia.org/wiki/Globally_unique_identifier)) is stored in this
        /// field.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("collection_id")]
        public string CollectionId { get; set; }

        /// <summary>
        /// Essays about the folder go into this field!
        /// </summary>
        [JsonPropertyName("description")]
        public string Description { get; set; }

        [JsonPropertyName("events")]
        public PostmanEvent[] Events { get; set; }

        /// <summary>
        /// Postman preserves the order of your folders within each folder. This field holds a
        /// sequence of [UUIDs](https://en.wikipedia.org/wiki/Globally_unique_identifier), where each
        /// ID corresponds to a particular collection folder.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("folders_order")]
        public string[] FoldersOrder { get; set; }

        /// <summary>
        /// In order to be able to uniquely identify different folders within a collection, Postman
        /// assigns each folder a unique ID (a
        /// [UUID](https://en.wikipedia.org/wiki/Globally_unique_identifier)). This field contains
        /// that value.
        /// </summary>
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// A folder's friendly name is defined by this field. You would want to set this field to a
        /// value that would allow you to easily identify this folder.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// Postman preserves the order of your requests within each folder. This field holds a
        /// sequence of [UUIDs](https://en.wikipedia.org/wiki/Globally_unique_identifier), where each
        /// ID corresponds to a particular Postman request.
        /// </summary>
        [JsonPropertyName("order")]
        public string[] Order { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("protocolProfileBehavior")]
        public Dictionary<string, object> ProtocolProfileBehavior { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("variables")]
        public PostmanVariable[] Variables { get; set; }
    }

    /// <summary>
    /// A request represents an HTTP request.
    /// </summary>
    public partial class PostmanRequest
    {
        [JsonPropertyName("auth")]
        public PostmanAuth Auth { get; set; }

        /// <summary>
        /// This field contains the unique ID of the collection to which this request belongs.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("collection")]
        public string Collection { get; set; }

        /// <summary>
        /// This field contains the unique ID of the collection to which this request belongs.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("collectionId")]
        public string CollectionId { get; set; }

        [JsonPropertyName("currentHelper")]
        public string CurrentHelper { get; set; }

        [JsonPropertyName("data")]
        public PostmanDatum[] Data { get; set; }

        /// <summary>
        /// When set to true, prevents request body from being sent.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("dataDisabled")]
        public bool? DataDisabled { get; set; }

        [JsonPropertyName("dataMode")]
        public PostmanDataMode? DataMode { get; set; }

        /// <summary>
        /// Additional configurations and options set for various body modes.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("dataOptions")]
        public Dictionary<string, object> DataOptions { get; set; }

        /// <summary>
        /// The description of this request. Can be as long as you want. Postman also supports two
        /// formats for your description, ``markdown`` and ``html``.
        /// </summary>
        [JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// A request can have an associated description text. Since description is meant to be long,
        /// it can be in either ``html`` or ``markdown`` formats. This field specifies that format.
        /// </summary>
        [JsonPropertyName("descriptionFormat")]
        public PostmanDescriptionFormat? DescriptionFormat { get; set; }

        [JsonPropertyName("events")]
        public PostmanEvent[] Events { get; set; }

        /// <summary>
        /// Postman requests may or may not be a part of a folder. If this request belongs to a
        /// folder, that folder's unique ID (which is a
        /// [UUID](https://en.wikipedia.org/wiki/Globally_unique_identifier)) is stored in this field.
        /// </summary>
        [JsonPropertyName("folder")]
        public string Folder { get; set; }

        /// <summary>
        /// This field contains the GraphQL request body
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("graphqlModeData")]
        public Dictionary<string, object> GraphqlModeData { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("headerData")]
        public PostmanHeader[] HeaderData { get; set; }

        /// <summary>
        /// No HTTP request is complete without its headers, and the same is true for a Postman
        /// request. This field contains all the HTTP Headers in a raw string format.
        /// </summary>
        [JsonPropertyName("headers")]
        public string Headers { get; set; }

        [JsonPropertyName("helperAttributes")]
        public PostmanHelperAttributes? HelperAttributes { get; set; }

        /// <summary>
        /// Postman can store a number of requests in each collection. In order to preserve the order
        /// of each request, we need to be able to identify requests uniquely. This field is a UUID
        /// assigned to each request.
        /// </summary>
        [JsonPropertyName("id")]
        public string Id { get; set; }

        [JsonPropertyName("method")]
        public string Method { get; set; }

        /// <summary>
        /// Sometimes, you just need to call your request 'Bob'. Postman will let you do that, and
        /// store the name you give in this field.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pathVariableData")]
        public PostmanPathVariable[] PathVariableData { get; set; }

        /// <summary>
        /// A Postman request allows you to use Path Variables in a request, e.g:
        /// ``/search/:bookId``. This field stores these variables.
        /// </summary>
        [JsonPropertyName("pathVariables")]
        public PostmanPathVariables? PathVariables { get; set; }

        [JsonPropertyName("preRequestScript")]
        public string PreRequestScript { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("protocolProfileBehavior")]
        public Dictionary<string, object> ProtocolProfileBehavior { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("queryParams")]
        public PostmanUrlParam[] QueryParams { get; set; }

        /// <summary>
        /// Contains the raw data (parameters) that Postman sends to the server
        /// </summary>
        [JsonPropertyName("rawModeData")]
        public PostmanValue? RawModeData { get; set; }

        /// <summary>
        /// A Postman request can have multiple responses associated with it. These responses are
        /// stored in this field.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("responses")]
        public PostmanResponse[] Responses { get; set; }

        /// <summary>
        /// Postman preserves the order of your responses within each request. This field holds a
        /// sequence of [UUIDs](https://en.wikipedia.org/wiki/Globally_unique_identifier), where each
        /// ID corresponds to a particular response.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("responses_order")]
        public string[] ResponsesOrder { get; set; }

        [JsonPropertyName("tests")]
        public string Tests { get; set; }

        /// <summary>
        /// The timestamp for this request.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("time")]
        public double? Time { get; set; }

        /// <summary>
        /// Contains the complete URL for this request, along with the path variables, if any.
        /// </summary>
        [JsonPropertyName("url")]
        public string Url { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("variables")]
        public PostmanVariable[] Variables { get; set; }
    }

    /// <summary>
    /// Data is an array of key-values that the request goes with. POST data, PUT data, etc goes
    /// here.
    /// </summary>
    public partial class PostmanDatum
    {
        /// <summary>
        /// Override Content-Type header of this form data entity.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("contentType")]
        public string ContentType { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("description")]
        public string Description { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("enabled")]
        public bool? Enabled { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("key")]
        public string Key { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public PostmanDatumType? Type { get; set; }

        [JsonPropertyName("value")]
        public PostmanValue? Value { get; set; }
    }

    public partial class PostmanHeaderClass
    {
        /// <summary>
        /// You can associate descriptions with headers too.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// Name of the header goes here. e.g: `Content-Type`
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("key")]
        public string Key { get; set; }

        /// <summary>
        /// The value of the header
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("value")]
        public string Value { get; set; }
    }

    /// <summary>
    /// The attributes for API Key Authentication. e.g. key, value, in.
    ///
    /// The attributes for [AWS
    /// Auth](http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html). e.g.
    /// accessKey, secretKey, region, service.
    ///
    /// The attributes for [Digest
    /// Authentication](https://en.wikipedia.org/wiki/Digest_access_authentication). e.g.
    /// username, password, realm, nonce, nonceCount, algorithm, qop, opaque, clientNonce.
    ///
    /// The attributes for [Akamai EdgeGrid
    /// Authentication](https://developer.akamai.com/legacy/introduction/Client_Auth.html). e.g.
    /// accessToken, clientToken, clientSecret, baseURL, nonce, timestamp, headersToSign.
    ///
    /// The attributes for [Hawk Authentication](https://github.com/hueniverse/hawk). e.g.
    /// authId, authKey, algorith, user, nonce, extraData, appId, delegation, timestamp.
    ///
    /// The attributes for [NTLM
    /// Authentication](https://msdn.microsoft.com/en-us/library/cc237488.aspx). e.g. username,
    /// password, domain, workstation.
    ///
    /// The attributes for [Basic
    /// Authentication](https://en.wikipedia.org/wiki/Basic_access_authentication). e.g.
    /// username, password.
    ///
    /// The attributes for [Bearer Token Authentication](https://tools.ietf.org/html/rfc6750).
    /// e.g. token.
    ///
    /// The attributes for [OAuth1](https://oauth.net/1/). e.g. consumerKey, consumerSecret,
    /// token, tokenSecret, signatureMethod, timestamp, nonce, version, realm, encodeOAuthSign.
    ///
    /// The attributes for [OAuth2](https://oauth.net/2/). e.g. accessToken, addTokenTo.
    /// </summary>
    public partial class PostmanApiKeyAuthentication
    {
        /// <summary>
        /// This field contains the type of the helper. In this case, it is ``apikey``
        ///
        /// This field contains the type of the helper. In this case, it is ``awsSigV4``
        ///
        /// This field contains the type of the helper. In this case, it is ``digest``
        ///
        /// This field contains the type of the helper. In this case, it is ``edgegrid``
        ///
        /// This field contains the type of the Postman helper. In this case, it is ``hawk``
        ///
        /// This field contains the type of the helper. In this case, it is ``ntlm``
        ///
        /// This field contains the type of the helper. In this case, it is ``basic``
        ///
        /// This field contains the type of the helper. In this case, it is ``bearer``
        ///
        /// This field contains the type of the helper. In this case, it is ``oAuth1``
        ///
        /// This field contains the type of the helper. In this case, it is ``oAuth2``
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("id")]
        public PostmanId? Id { get; set; }
    }

    public partial class PostmanPathVariableClass
    {
        /// <summary>
        /// Extra description about a path variable may be added in this field.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// The identifier of a path variable goes here.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("key")]
        public string Key { get; set; }

        /// <summary>
        /// The value of the path variable will be substituted in place of the key.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("value")]
        public string Value { get; set; }
    }

    public partial class PostmanUrlParamClass
    {
        /// <summary>
        /// You can associate descriptions with URL parameters, which are stored in this field.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// The key of a URL parameter.
        /// </summary>
        [JsonPropertyName("key")]
        public string Key { get; set; }

        /// <summary>
        /// The value of a URL parameter
        /// </summary>
        [JsonPropertyName("value")]
        public string Value { get; set; }
    }

    public partial class PostmanResponseClass
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("cookies")]
        public PostmanCookie[] Cookies { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("headers")]
        public PostmanHeaderElement[] Headers { get; set; }

        /// <summary>
        /// In order to unambiguously identify a response, Postman assigns a UUID to it, and stores
        /// it in this field.
        /// </summary>
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// The language associated with the response.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("language")]
        public PostmanLanguage? Language { get; set; }

        /// <summary>
        /// Mimetype of the response.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("mime")]
        public string Mime { get; set; }

        /// <summary>
        /// A response can have a friendly name, which goes here.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// The data type of the raw response.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("rawDataType")]
        public string RawDataType { get; set; }

        /// <summary>
        /// A response is associated with a request. This fields contains the UUID of the request
        /// corresponding to this response.
        /// </summary>
        [JsonPropertyName("request")]
        public PostmanPathVariables Request { get; set; }

        [JsonPropertyName("responseCode")]
        public PostmanResponseCode ResponseCode { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("status")]
        public string Status { get; set; }

        /// <summary>
        /// The raw text of the response.
        /// </summary>
        [JsonPropertyName("text")]
        public string Text { get; set; }

        /// <summary>
        /// The time taken by this particular HTTP transaction to complete is stored in this field.
        /// For manually created responses, this field can be set to ``null``.
        /// </summary>
        [JsonPropertyName("time")]
        public PostmanTime? Time { get; set; }

        /// <summary>
        /// Set of timing information related to request and response in milliseconds
        /// </summary>
        [JsonPropertyName("timings")]
        public Dictionary<string, object> Timings { get; set; }
    }

    public partial class PostmanCookie
    {
        /// <summary>
        /// The domain for which this cookie is valid.
        /// </summary>
        [JsonPropertyName("domain")]
        public string Domain { get; set; }

        /// <summary>
        /// The timestamp of the time when the cookie expires.
        /// </summary>
        [JsonPropertyName("expirationDate")]
        public double ExpirationDate { get; set; }

        /// <summary>
        /// Human readable expiration time.
        /// </summary>
        [JsonPropertyName("expires")]
        public string Expires { get; set; }

        /// <summary>
        /// Indicates if this cookie is Host Only.
        /// </summary>
        [JsonPropertyName("hostOnly")]
        public bool HostOnly { get; set; }

        /// <summary>
        /// Indicates if this cookie is HTTP Only.
        /// </summary>
        [JsonPropertyName("httpOnly")]
        public bool HttpOnly { get; set; }

        /// <summary>
        /// This is the name of the Cookie.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// The path associated with the Cookie.
        /// </summary>
        [JsonPropertyName("path")]
        public string Path { get; set; }

        /// <summary>
        /// Indicates if the 'secure' flag is set on the Cookie.
        /// </summary>
        [JsonPropertyName("secure")]
        public bool Secure { get; set; }

        /// <summary>
        /// True if the cookie is a session cookie.
        /// </summary>
        [JsonPropertyName("session")]
        public bool Session { get; set; }

        /// <summary>
        /// The ID of the cookie store containing this cookie.
        /// </summary>
        [JsonPropertyName("storeId")]
        public string StoreId { get; set; }

        /// <summary>
        /// The value of the Cookie.
        /// </summary>
        [JsonPropertyName("value")]
        public string Value { get; set; }
    }

    public partial class PostmanHeaderElement
    {
        /// <summary>
        /// An optional description about the header.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// The left hand side (LHS) or 'key' of the header.
        /// </summary>
        [JsonPropertyName("key")]
        public string Key { get; set; }

        /// <summary>
        /// Some headers can have names associated with them, which are stored in this field.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// Value of the header, or the right hand side (RHS).
        /// </summary>
        [JsonPropertyName("value")]
        public string Value { get; set; }
    }

    public partial class PostmanResponseCode
    {
        /// <summary>
        /// The numeric HTTP response code.
        /// </summary>
        [JsonPropertyName("code")]
        public double Code { get; set; }

        /// <summary>
        /// Detailed explanation of the response code.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("detail")]
        public string Detail { get; set; }

        /// <summary>
        /// The textual HTTP response code.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; }
    }

    public enum PostmanAuthType { Apikey, Awsv4, Basic, Bearer, Digest, Edgegrid, Hawk, Noauth, Ntlm, Oauth1, Oauth2 };

    /// <summary>
    /// A variable may have multiple types. This field specifies the type of the variable.
    /// </summary>
    public enum PostmanVariableType { Any, Boolean, Number, String };

    public enum PostmanDatumType { File, Text };

    /// <summary>
    /// A request can have a specific data mode, and Postman supports these.
    /// </summary>
    public enum PostmanDataMode { Binary, Graphql, Params, Raw, Urlencoded };

    public enum PostmanDescriptionFormat { Html, Markdown };

    /// <summary>
    /// This field contains the type of the helper. In this case, it is ``apikey``
    /// </summary>
    public enum PostmanId { Apikey, AwsSigV4, Basic, Bearer, Digest, Edgegrid, Hawk, Ntlm, OAuth1, OAuth2 };

    /// <summary>
    /// The language associated with the response.
    /// </summary>
    public enum PostmanLanguage { Html, Javascript, Text, Xml };

    /// <summary>
    /// The host for the URL, E.g: api.yourdomain.com. Can be stored as a string or as an array
    /// of strings.
    /// </summary>
    public partial struct PostmanHost
    {
        public string String;
        public string[] StringArray;

        public static implicit operator PostmanHost(string String) => new PostmanHost { String = String };
        public static implicit operator PostmanHost(string[] StringArray) => new PostmanHost { StringArray = StringArray };
    }

    /// <summary>
    /// The complete path of the current url, broken down into segments. A segment could be a
    /// string, or a path variable.
    /// </summary>
    public partial struct PostmanPathElement
    {
        public PostmanPathClass PathClass;
        public string String;

        public static implicit operator PostmanPathElement(PostmanPathClass PathClass) => new PostmanPathElement { PathClass = PathClass };
        public static implicit operator PostmanPathElement(string String) => new PostmanPathElement { String = String };
    }

    public partial struct PostmanUrlPath
    {
        public PostmanPathElement[] AnythingArray;
        public string String;

        public static implicit operator PostmanUrlPath(PostmanPathElement[] AnythingArray) => new PostmanUrlPath { AnythingArray = AnythingArray };
        public static implicit operator PostmanUrlPath(string String) => new PostmanUrlPath { String = String };
    }

    /// <summary>
    /// A Description can be a raw text, or be an object, which holds the description along with
    /// its format.
    /// </summary>
    public partial struct PostmanDescriptionUnion
    {
        public PostmanDescription Description;
        public string String;

        public static implicit operator PostmanDescriptionUnion(PostmanDescription Description) => new PostmanDescriptionUnion { Description = Description };
        public static implicit operator PostmanDescriptionUnion(string String) => new PostmanDescriptionUnion { String = String };
        public bool IsNull => Description == null && String == null;
    }

    /// <summary>
    /// If object, contains the complete broken-down URL for this request. If string, contains
    /// the literal request URL.
    /// </summary>
    public partial struct PostmanUrl
    {
        public string String;
        public PostmanUrlClass UrlClass;

        public static implicit operator PostmanUrl(string String) => new PostmanUrl { String = String };
        public static implicit operator PostmanUrl(PostmanUrlClass UrlClass) => new PostmanUrl { UrlClass = UrlClass };
    }

    /// <summary>
    /// Contains the raw data (parameters) that Postman sends to the server
    /// </summary>
    public partial struct PostmanValue
    {
        public object[] AnythingArray;
        public string String;

        public static implicit operator PostmanValue(object[] AnythingArray) => new PostmanValue { AnythingArray = AnythingArray };
        public static implicit operator PostmanValue(string String) => new PostmanValue { String = String };
        public bool IsNull => AnythingArray == null && String == null;
    }

    /// <summary>
    /// A response represents an HTTP response.
    /// </summary>
    public partial struct PostmanHeader
    {
        public object[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public PostmanHeaderClass HeaderClass;
        public long? Integer;
        public string String;

        public static implicit operator PostmanHeader(object[] AnythingArray) => new PostmanHeader { AnythingArray = AnythingArray };
        public static implicit operator PostmanHeader(bool Bool) => new PostmanHeader { Bool = Bool };
        public static implicit operator PostmanHeader(double Double) => new PostmanHeader { Double = Double };
        public static implicit operator PostmanHeader(PostmanHeaderClass HeaderClass) => new PostmanHeader { HeaderClass = HeaderClass };
        public static implicit operator PostmanHeader(long Integer) => new PostmanHeader { Integer = Integer };
        public static implicit operator PostmanHeader(string String) => new PostmanHeader { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && HeaderClass == null && Double == null && Integer == null && String == null;
    }

    /// <summary>
    /// A helper may require a number of parameters to actually be helpful. The parameters used
    /// by the helper can be stored in this field, as an object. E.g when using Basic
    /// Authentication, the username and password will be stored here.
    /// </summary>
    public partial struct PostmanHelperAttributes
    {
        public PostmanApiKeyAuthentication ApiKeyAuthentication;
        public string String;

        public static implicit operator PostmanHelperAttributes(PostmanApiKeyAuthentication ApiKeyAuthentication) => new PostmanHelperAttributes { ApiKeyAuthentication = ApiKeyAuthentication };
        public static implicit operator PostmanHelperAttributes(string String) => new PostmanHelperAttributes { String = String };
        public bool IsNull => ApiKeyAuthentication == null && String == null;
    }

    /// <summary>
    /// A request URL may contain one or more path variables (e.g: `:varname`)
    /// </summary>
    public partial struct PostmanPathVariable
    {
        public object[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public long? Integer;
        public PostmanPathVariableClass PathVariableClass;
        public string String;

        public static implicit operator PostmanPathVariable(object[] AnythingArray) => new PostmanPathVariable { AnythingArray = AnythingArray };
        public static implicit operator PostmanPathVariable(bool Bool) => new PostmanPathVariable { Bool = Bool };
        public static implicit operator PostmanPathVariable(double Double) => new PostmanPathVariable { Double = Double };
        public static implicit operator PostmanPathVariable(long Integer) => new PostmanPathVariable { Integer = Integer };
        public static implicit operator PostmanPathVariable(PostmanPathVariableClass PathVariableClass) => new PostmanPathVariable { PathVariableClass = PathVariableClass };
        public static implicit operator PostmanPathVariable(string String) => new PostmanPathVariable { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && PathVariableClass == null && Double == null && Integer == null && String == null;
    }

    /// <summary>
    /// A Postman request allows you to use Path Variables in a request, e.g:
    /// ``/search/:bookId``. This field stores these variables.
    ///
    /// A response is associated with a request. This fields contains the UUID of the request
    /// corresponding to this response.
    /// </summary>
    public partial struct PostmanPathVariables
    {
        public Dictionary<string, object> AnythingMap;
        public string String;

        public static implicit operator PostmanPathVariables(Dictionary<string, object> AnythingMap) => new PostmanPathVariables { AnythingMap = AnythingMap };
        public static implicit operator PostmanPathVariables(string String) => new PostmanPathVariables { String = String };
        public bool IsNull => AnythingMap == null && String == null;
    }

    /// <summary>
    /// A response represents an HTTP response.
    /// </summary>
    public partial struct PostmanUrlParam
    {
        public object[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public long? Integer;
        public string String;
        public PostmanUrlParamClass UrlParamClass;

        public static implicit operator PostmanUrlParam(object[] AnythingArray) => new PostmanUrlParam { AnythingArray = AnythingArray };
        public static implicit operator PostmanUrlParam(bool Bool) => new PostmanUrlParam { Bool = Bool };
        public static implicit operator PostmanUrlParam(double Double) => new PostmanUrlParam { Double = Double };
        public static implicit operator PostmanUrlParam(long Integer) => new PostmanUrlParam { Integer = Integer };
        public static implicit operator PostmanUrlParam(string String) => new PostmanUrlParam { String = String };
        public static implicit operator PostmanUrlParam(PostmanUrlParamClass UrlParamClass) => new PostmanUrlParam { UrlParamClass = UrlParamClass };
        public bool IsNull => AnythingArray == null && Bool == null && UrlParamClass == null && Double == null && Integer == null && String == null;
    }

    /// <summary>
    /// The time taken by this particular HTTP transaction to complete is stored in this field.
    /// For manually created responses, this field can be set to ``null``.
    /// </summary>
    public partial struct PostmanTime
    {
        public double? Double;
        public string String;

        public static implicit operator PostmanTime(double Double) => new PostmanTime { Double = Double };
        public static implicit operator PostmanTime(string String) => new PostmanTime { String = String };
        public bool IsNull => Double == null && String == null;
    }

    /// <summary>
    /// A response represents an HTTP response.
    /// </summary>
    public partial struct PostmanResponse
    {
        public object[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public long? Integer;
        public PostmanResponseClass ResponseClass;
        public string String;

        public static implicit operator PostmanResponse(object[] AnythingArray) => new PostmanResponse { AnythingArray = AnythingArray };
        public static implicit operator PostmanResponse(bool Bool) => new PostmanResponse { Bool = Bool };
        public static implicit operator PostmanResponse(double Double) => new PostmanResponse { Double = Double };
        public static implicit operator PostmanResponse(long Integer) => new PostmanResponse { Integer = Integer };
        public static implicit operator PostmanResponse(PostmanResponseClass ResponseClass) => new PostmanResponse { ResponseClass = ResponseClass };
        public static implicit operator PostmanResponse(string String) => new PostmanResponse { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && ResponseClass == null && Double == null && Integer == null && String == null;
    }

    public partial class PostmanCollection1_0_0
    {
        public static PostmanCollection1_0_0 FromJson(string json) => JsonSerializer.Deserialize<PostmanCollection1_0_0>(json, PostmanCollectionV1_0_0.PostmanConverter.Settings);
    }

    public static class PostmanSerialize
    {
        public static string ToJson(this PostmanCollection1_0_0 self) => JsonSerializer.Serialize(self, PostmanCollectionV1_0_0.PostmanConverter.Settings);
    }

    internal static class PostmanConverter
    {
        public static readonly JsonSerializerOptions Settings = new(JsonSerializerDefaults.General)
        {
            Converters =
            {
                PostmanAuthTypeConverter.Singleton,
                PostmanHostConverter.Singleton,
                PostmanUrlConverter.Singleton,
                PostmanUrlPathConverter.Singleton,
                PostmanPathElementConverter.Singleton,
                PostmanDescriptionUnionConverter.Singleton,
                PostmanVariableTypeConverter.Singleton,
                PostmanDatumTypeConverter.Singleton,
                PostmanValueConverter.Singleton,
                PostmanDataModeConverter.Singleton,
                PostmanDescriptionFormatConverter.Singleton,
                PostmanHeaderConverter.Singleton,
                PostmanHelperAttributesConverter.Singleton,
                PostmanIdConverter.Singleton,
                PostmanPathVariableConverter.Singleton,
                PostmanPathVariablesConverter.Singleton,
                PostmanUrlParamConverter.Singleton,
                PostmanResponseConverter.Singleton,
                PostmanLanguageConverter.Singleton,
                PostmanTimeConverter.Singleton,
                new PostmanDateOnlyConverter(),
                new PostmanTimeOnlyConverter(),
                PostmanIsoDateTimeOffsetConverter.Singleton
            },
        };
    }

    internal class PostmanAuthTypeConverter : JsonConverter<PostmanAuthType>
    {
        public override bool CanConvert(Type t) => t == typeof(PostmanAuthType);

        public override PostmanAuthType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "apikey":
                    return PostmanAuthType.Apikey;
                case "awsv4":
                    return PostmanAuthType.Awsv4;
                case "basic":
                    return PostmanAuthType.Basic;
                case "bearer":
                    return PostmanAuthType.Bearer;
                case "digest":
                    return PostmanAuthType.Digest;
                case "edgegrid":
                    return PostmanAuthType.Edgegrid;
                case "hawk":
                    return PostmanAuthType.Hawk;
                case "noauth":
                    return PostmanAuthType.Noauth;
                case "ntlm":
                    return PostmanAuthType.Ntlm;
                case "oauth1":
                    return PostmanAuthType.Oauth1;
                case "oauth2":
                    return PostmanAuthType.Oauth2;
            }
            throw new Exception("Cannot unmarshal type AuthType");
        }

        public override void Write(Utf8JsonWriter writer, PostmanAuthType value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case PostmanAuthType.Apikey:
                    JsonSerializer.Serialize(writer, "apikey", options);
                    return;
                case PostmanAuthType.Awsv4:
                    JsonSerializer.Serialize(writer, "awsv4", options);
                    return;
                case PostmanAuthType.Basic:
                    JsonSerializer.Serialize(writer, "basic", options);
                    return;
                case PostmanAuthType.Bearer:
                    JsonSerializer.Serialize(writer, "bearer", options);
                    return;
                case PostmanAuthType.Digest:
                    JsonSerializer.Serialize(writer, "digest", options);
                    return;
                case PostmanAuthType.Edgegrid:
                    JsonSerializer.Serialize(writer, "edgegrid", options);
                    return;
                case PostmanAuthType.Hawk:
                    JsonSerializer.Serialize(writer, "hawk", options);
                    return;
                case PostmanAuthType.Noauth:
                    JsonSerializer.Serialize(writer, "noauth", options);
                    return;
                case PostmanAuthType.Ntlm:
                    JsonSerializer.Serialize(writer, "ntlm", options);
                    return;
                case PostmanAuthType.Oauth1:
                    JsonSerializer.Serialize(writer, "oauth1", options);
                    return;
                case PostmanAuthType.Oauth2:
                    JsonSerializer.Serialize(writer, "oauth2", options);
                    return;
            }
            throw new Exception("Cannot marshal type AuthType");
        }

        public static readonly PostmanAuthTypeConverter Singleton = new PostmanAuthTypeConverter();
    }

    internal class PostmanHostConverter : JsonConverter<PostmanHost>
    {
        public override bool CanConvert(Type t) => t == typeof(PostmanHost);

        public override PostmanHost Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new PostmanHost { String = stringValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<string[]>(ref reader, options);
                    return new PostmanHost { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Host");
        }

        public override void Write(Utf8JsonWriter writer, PostmanHost value, JsonSerializerOptions options)
        {
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.StringArray != null)
            {
                JsonSerializer.Serialize(writer, value.StringArray, options);
                return;
            }
            throw new Exception("Cannot marshal type Host");
        }

        public static readonly PostmanHostConverter Singleton = new PostmanHostConverter();
    }

    internal class PostmanUrlConverter : JsonConverter<PostmanUrl>
    {
        public override bool CanConvert(Type t) => t == typeof(PostmanUrl);

        public override PostmanUrl Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new PostmanUrl { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<PostmanUrlClass>(ref reader, options);
                    return new PostmanUrl { UrlClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type Url");
        }

        public override void Write(Utf8JsonWriter writer, PostmanUrl value, JsonSerializerOptions options)
        {
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.UrlClass != null)
            {
                JsonSerializer.Serialize(writer, value.UrlClass, options);
                return;
            }
            throw new Exception("Cannot marshal type Url");
        }

        public static readonly PostmanUrlConverter Singleton = new PostmanUrlConverter();
    }

    internal class PostmanUrlPathConverter : JsonConverter<PostmanUrlPath>
    {
        public override bool CanConvert(Type t) => t == typeof(PostmanUrlPath);

        public override PostmanUrlPath Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new PostmanUrlPath { String = stringValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<PostmanPathElement[]>(ref reader, options);
                    return new PostmanUrlPath { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type UrlPath");
        }

        public override void Write(Utf8JsonWriter writer, PostmanUrlPath value, JsonSerializerOptions options)
        {
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AnythingArray != null)
            {
                JsonSerializer.Serialize(writer, value.AnythingArray, options);
                return;
            }
            throw new Exception("Cannot marshal type UrlPath");
        }

        public static readonly PostmanUrlPathConverter Singleton = new PostmanUrlPathConverter();
    }

    internal class PostmanPathElementConverter : JsonConverter<PostmanPathElement>
    {
        public override bool CanConvert(Type t) => t == typeof(PostmanPathElement);

        public override PostmanPathElement Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new PostmanPathElement { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<PostmanPathClass>(ref reader, options);
                    return new PostmanPathElement { PathClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type PathElement");
        }

        public override void Write(Utf8JsonWriter writer, PostmanPathElement value, JsonSerializerOptions options)
        {
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.PathClass != null)
            {
                JsonSerializer.Serialize(writer, value.PathClass, options);
                return;
            }
            throw new Exception("Cannot marshal type PathElement");
        }

        public static readonly PostmanPathElementConverter Singleton = new PostmanPathElementConverter();
    }

    internal class PostmanDescriptionUnionConverter : JsonConverter<PostmanDescriptionUnion>
    {
        public override bool CanConvert(Type t) => t == typeof(PostmanDescriptionUnion);

        public override PostmanDescriptionUnion Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new PostmanDescriptionUnion { };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new PostmanDescriptionUnion { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<PostmanDescription>(ref reader, options);
                    return new PostmanDescriptionUnion { Description = objectValue };
            }
            throw new Exception("Cannot unmarshal type DescriptionUnion");
        }

        public override void Write(Utf8JsonWriter writer, PostmanDescriptionUnion value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.Description != null)
            {
                JsonSerializer.Serialize(writer, value.Description, options);
                return;
            }
            throw new Exception("Cannot marshal type DescriptionUnion");
        }

        public static readonly PostmanDescriptionUnionConverter Singleton = new PostmanDescriptionUnionConverter();
    }

    internal class PostmanVariableTypeConverter : JsonConverter<PostmanVariableType>
    {
        public override bool CanConvert(Type t) => t == typeof(PostmanVariableType);

        public override PostmanVariableType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "any":
                    return PostmanVariableType.Any;
                case "boolean":
                    return PostmanVariableType.Boolean;
                case "number":
                    return PostmanVariableType.Number;
                case "string":
                    return PostmanVariableType.String;
            }
            throw new Exception("Cannot unmarshal type VariableType");
        }

        public override void Write(Utf8JsonWriter writer, PostmanVariableType value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case PostmanVariableType.Any:
                    JsonSerializer.Serialize(writer, "any", options);
                    return;
                case PostmanVariableType.Boolean:
                    JsonSerializer.Serialize(writer, "boolean", options);
                    return;
                case PostmanVariableType.Number:
                    JsonSerializer.Serialize(writer, "number", options);
                    return;
                case PostmanVariableType.String:
                    JsonSerializer.Serialize(writer, "string", options);
                    return;
            }
            throw new Exception("Cannot marshal type VariableType");
        }

        public static readonly PostmanVariableTypeConverter Singleton = new PostmanVariableTypeConverter();
    }

    internal class PostmanDatumTypeConverter : JsonConverter<PostmanDatumType>
    {
        public override bool CanConvert(Type t) => t == typeof(PostmanDatumType);

        public override PostmanDatumType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "file":
                    return PostmanDatumType.File;
                case "text":
                    return PostmanDatumType.Text;
            }
            throw new Exception("Cannot unmarshal type DatumType");
        }

        public override void Write(Utf8JsonWriter writer, PostmanDatumType value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case PostmanDatumType.File:
                    JsonSerializer.Serialize(writer, "file", options);
                    return;
                case PostmanDatumType.Text:
                    JsonSerializer.Serialize(writer, "text", options);
                    return;
            }
            throw new Exception("Cannot marshal type DatumType");
        }

        public static readonly PostmanDatumTypeConverter Singleton = new PostmanDatumTypeConverter();
    }

    internal class PostmanValueConverter : JsonConverter<PostmanValue>
    {
        public override bool CanConvert(Type t) => t == typeof(PostmanValue);

        public override PostmanValue Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new PostmanValue { };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new PostmanValue { String = stringValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<object[]>(ref reader, options);
                    return new PostmanValue { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Value");
        }

        public override void Write(Utf8JsonWriter writer, PostmanValue value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AnythingArray != null)
            {
                JsonSerializer.Serialize(writer, value.AnythingArray, options);
                return;
            }
            throw new Exception("Cannot marshal type Value");
        }

        public static readonly PostmanValueConverter Singleton = new PostmanValueConverter();
    }

    internal class PostmanDataModeConverter : JsonConverter<PostmanDataMode>
    {
        public override bool CanConvert(Type t) => t == typeof(PostmanDataMode);

        public override PostmanDataMode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "binary":
                    return PostmanDataMode.Binary;
                case "graphql":
                    return PostmanDataMode.Graphql;
                case "params":
                    return PostmanDataMode.Params;
                case "raw":
                    return PostmanDataMode.Raw;
                case "urlencoded":
                    return PostmanDataMode.Urlencoded;
            }
            throw new Exception("Cannot unmarshal type DataMode");
        }

        public override void Write(Utf8JsonWriter writer, PostmanDataMode value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case PostmanDataMode.Binary:
                    JsonSerializer.Serialize(writer, "binary", options);
                    return;
                case PostmanDataMode.Graphql:
                    JsonSerializer.Serialize(writer, "graphql", options);
                    return;
                case PostmanDataMode.Params:
                    JsonSerializer.Serialize(writer, "params", options);
                    return;
                case PostmanDataMode.Raw:
                    JsonSerializer.Serialize(writer, "raw", options);
                    return;
                case PostmanDataMode.Urlencoded:
                    JsonSerializer.Serialize(writer, "urlencoded", options);
                    return;
            }
            throw new Exception("Cannot marshal type DataMode");
        }

        public static readonly PostmanDataModeConverter Singleton = new PostmanDataModeConverter();
    }

    internal class PostmanDescriptionFormatConverter : JsonConverter<PostmanDescriptionFormat>
    {
        public override bool CanConvert(Type t) => t == typeof(PostmanDescriptionFormat);

        public override PostmanDescriptionFormat Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "html":
                    return PostmanDescriptionFormat.Html;
                case "markdown":
                    return PostmanDescriptionFormat.Markdown;
            }
            throw new Exception("Cannot unmarshal type DescriptionFormat");
        }

        public override void Write(Utf8JsonWriter writer, PostmanDescriptionFormat value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case PostmanDescriptionFormat.Html:
                    JsonSerializer.Serialize(writer, "html", options);
                    return;
                case PostmanDescriptionFormat.Markdown:
                    JsonSerializer.Serialize(writer, "markdown", options);
                    return;
            }
            throw new Exception("Cannot marshal type DescriptionFormat");
        }

        public static readonly PostmanDescriptionFormatConverter Singleton = new PostmanDescriptionFormatConverter();
    }

    internal class PostmanHeaderConverter : JsonConverter<PostmanHeader>
    {
        public override bool CanConvert(Type t) => t == typeof(PostmanHeader);

        public override PostmanHeader Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new PostmanHeader { };
                case JsonTokenType.Number:
                    if (reader.TryGetInt64(out var integerValue))
                        return new PostmanHeader {Integer = integerValue};
                    else
                        return new PostmanHeader {Double = reader.GetDouble()};
                case JsonTokenType.True:
                case JsonTokenType.False:
                    var boolValue = reader.GetBoolean();
                    return new PostmanHeader { Bool = boolValue };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new PostmanHeader { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<PostmanHeaderClass>(ref reader, options);
                    return new PostmanHeader { HeaderClass = objectValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<object[]>(ref reader, options);
                    return new PostmanHeader { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Header");
        }

        public override void Write(Utf8JsonWriter writer, PostmanHeader value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.Integer != null)
            {
                JsonSerializer.Serialize(writer, value.Integer.Value, options);
                return;
            }
            if (value.Double != null)
            {
                JsonSerializer.Serialize(writer, value.Double.Value, options);
                return;
            }
            if (value.Bool != null)
            {
                JsonSerializer.Serialize(writer, value.Bool.Value, options);
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AnythingArray != null)
            {
                JsonSerializer.Serialize(writer, value.AnythingArray, options);
                return;
            }
            if (value.HeaderClass != null)
            {
                JsonSerializer.Serialize(writer, value.HeaderClass, options);
                return;
            }
            throw new Exception("Cannot marshal type Header");
        }

        public static readonly PostmanHeaderConverter Singleton = new PostmanHeaderConverter();
    }

    internal class PostmanHelperAttributesConverter : JsonConverter<PostmanHelperAttributes>
    {
        public override bool CanConvert(Type t) => t == typeof(PostmanHelperAttributes);

        public override PostmanHelperAttributes Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new PostmanHelperAttributes { };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new PostmanHelperAttributes { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<PostmanApiKeyAuthentication>(ref reader, options);
                    return new PostmanHelperAttributes { ApiKeyAuthentication = objectValue };
            }
            throw new Exception("Cannot unmarshal type HelperAttributes");
        }

        public override void Write(Utf8JsonWriter writer, PostmanHelperAttributes value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.ApiKeyAuthentication != null)
            {
                JsonSerializer.Serialize(writer, value.ApiKeyAuthentication, options);
                return;
            }
            throw new Exception("Cannot marshal type HelperAttributes");
        }

        public static readonly PostmanHelperAttributesConverter Singleton = new PostmanHelperAttributesConverter();
    }

    internal class PostmanIdConverter : JsonConverter<PostmanId>
    {
        public override bool CanConvert(Type t) => t == typeof(PostmanId);

        public override PostmanId Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "apikey":
                    return PostmanId.Apikey;
                case "awsSigV4":
                    return PostmanId.AwsSigV4;
                case "basic":
                    return PostmanId.Basic;
                case "bearer":
                    return PostmanId.Bearer;
                case "digest":
                    return PostmanId.Digest;
                case "edgegrid":
                    return PostmanId.Edgegrid;
                case "hawk":
                    return PostmanId.Hawk;
                case "ntlm":
                    return PostmanId.Ntlm;
                case "oAuth1":
                    return PostmanId.OAuth1;
                case "oAuth2":
                    return PostmanId.OAuth2;
            }
            throw new Exception("Cannot unmarshal type Id");
        }

        public override void Write(Utf8JsonWriter writer, PostmanId value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case PostmanId.Apikey:
                    JsonSerializer.Serialize(writer, "apikey", options);
                    return;
                case PostmanId.AwsSigV4:
                    JsonSerializer.Serialize(writer, "awsSigV4", options);
                    return;
                case PostmanId.Basic:
                    JsonSerializer.Serialize(writer, "basic", options);
                    return;
                case PostmanId.Bearer:
                    JsonSerializer.Serialize(writer, "bearer", options);
                    return;
                case PostmanId.Digest:
                    JsonSerializer.Serialize(writer, "digest", options);
                    return;
                case PostmanId.Edgegrid:
                    JsonSerializer.Serialize(writer, "edgegrid", options);
                    return;
                case PostmanId.Hawk:
                    JsonSerializer.Serialize(writer, "hawk", options);
                    return;
                case PostmanId.Ntlm:
                    JsonSerializer.Serialize(writer, "ntlm", options);
                    return;
                case PostmanId.OAuth1:
                    JsonSerializer.Serialize(writer, "oAuth1", options);
                    return;
                case PostmanId.OAuth2:
                    JsonSerializer.Serialize(writer, "oAuth2", options);
                    return;
            }
            throw new Exception("Cannot marshal type Id");
        }

        public static readonly PostmanIdConverter Singleton = new PostmanIdConverter();
    }

    internal class PostmanPathVariableConverter : JsonConverter<PostmanPathVariable>
    {
        public override bool CanConvert(Type t) => t == typeof(PostmanPathVariable);

        public override PostmanPathVariable Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new PostmanPathVariable { };
                case JsonTokenType.Number:
                    if (reader.TryGetInt64(out var integerValue))
                        return new PostmanPathVariable {Integer = integerValue};
                    else
                        return new PostmanPathVariable { Double = reader.GetDouble() };
                case JsonTokenType.True:
                case JsonTokenType.False:
                    var boolValue = reader.GetBoolean();
                    return new PostmanPathVariable { Bool = boolValue };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new PostmanPathVariable { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<PostmanPathVariableClass>(ref reader, options);
                    return new PostmanPathVariable { PathVariableClass = objectValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<object[]>(ref reader, options);
                    return new PostmanPathVariable { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type PathVariable");
        }

        public override void Write(Utf8JsonWriter writer, PostmanPathVariable value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.Integer != null)
            {
                JsonSerializer.Serialize(writer, value.Integer.Value, options);
                return;
            }
            if (value.Double != null)
            {
                JsonSerializer.Serialize(writer, value.Double.Value, options);
                return;
            }
            if (value.Bool != null)
            {
                JsonSerializer.Serialize(writer, value.Bool.Value, options);
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AnythingArray != null)
            {
                JsonSerializer.Serialize(writer, value.AnythingArray, options);
                return;
            }
            if (value.PathVariableClass != null)
            {
                JsonSerializer.Serialize(writer, value.PathVariableClass, options);
                return;
            }
            throw new Exception("Cannot marshal type PathVariable");
        }

        public static readonly PostmanPathVariableConverter Singleton = new PostmanPathVariableConverter();
    }

    internal class PostmanPathVariablesConverter : JsonConverter<PostmanPathVariables>
    {
        public override bool CanConvert(Type t) => t == typeof(PostmanPathVariables);

        public override PostmanPathVariables Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new PostmanPathVariables { };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new PostmanPathVariables { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<Dictionary<string, object>>(ref reader, options);
                    return new PostmanPathVariables { AnythingMap = objectValue };
            }
            throw new Exception("Cannot unmarshal type PathVariables");
        }

        public override void Write(Utf8JsonWriter writer, PostmanPathVariables value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AnythingMap != null)
            {
                JsonSerializer.Serialize(writer, value.AnythingMap, options);
                return;
            }
            throw new Exception("Cannot marshal type PathVariables");
        }

        public static readonly PostmanPathVariablesConverter Singleton = new PostmanPathVariablesConverter();
    }

    internal class PostmanUrlParamConverter : JsonConverter<PostmanUrlParam>
    {
        public override bool CanConvert(Type t) => t == typeof(PostmanUrlParam);

        public override PostmanUrlParam Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new PostmanUrlParam { };
                case JsonTokenType.Number:
                    if (reader.TryGetInt64(out var integerValue))
                        return new PostmanUrlParam {Integer = integerValue};
                    else
                        return new PostmanUrlParam { Double = reader.GetDouble() };
                case JsonTokenType.True:
                case JsonTokenType.False:
                    var boolValue = reader.GetBoolean();
                    return new PostmanUrlParam { Bool = boolValue };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new PostmanUrlParam { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<PostmanUrlParamClass>(ref reader, options);
                    return new PostmanUrlParam { UrlParamClass = objectValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<object[]>(ref reader, options);
                    return new PostmanUrlParam { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type UrlParam");
        }

        public override void Write(Utf8JsonWriter writer, PostmanUrlParam value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.Integer != null)
            {
                JsonSerializer.Serialize(writer, value.Integer.Value, options);
                return;
            }
            if (value.Double != null)
            {
                JsonSerializer.Serialize(writer, value.Double.Value, options);
                return;
            }
            if (value.Bool != null)
            {
                JsonSerializer.Serialize(writer, value.Bool.Value, options);
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AnythingArray != null)
            {
                JsonSerializer.Serialize(writer, value.AnythingArray, options);
                return;
            }
            if (value.UrlParamClass != null)
            {
                JsonSerializer.Serialize(writer, value.UrlParamClass, options);
                return;
            }
            throw new Exception("Cannot marshal type UrlParam");
        }

        public static readonly PostmanUrlParamConverter Singleton = new PostmanUrlParamConverter();
    }

    internal class PostmanResponseConverter : JsonConverter<PostmanResponse>
    {
        public override bool CanConvert(Type t) => t == typeof(PostmanResponse);

        public override PostmanResponse Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new PostmanResponse { };
                case JsonTokenType.Number:
                    if (reader.TryGetInt64(out var integerValue))
                        return new PostmanResponse {Integer = integerValue};
                    else
                        return new PostmanResponse { Double = reader.GetDouble() };
                case JsonTokenType.True:
                case JsonTokenType.False:
                    var boolValue = reader.GetBoolean();
                    return new PostmanResponse { Bool = boolValue };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new PostmanResponse { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<PostmanResponseClass>(ref reader, options);
                    return new PostmanResponse { ResponseClass = objectValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<object[]>(ref reader, options);
                    return new PostmanResponse { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Response");
        }

        public override void Write(Utf8JsonWriter writer, PostmanResponse value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.Integer != null)
            {
                JsonSerializer.Serialize(writer, value.Integer.Value, options);
                return;
            }
            if (value.Double != null)
            {
                JsonSerializer.Serialize(writer, value.Double.Value, options);
                return;
            }
            if (value.Bool != null)
            {
                JsonSerializer.Serialize(writer, value.Bool.Value, options);
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AnythingArray != null)
            {
                JsonSerializer.Serialize(writer, value.AnythingArray, options);
                return;
            }
            if (value.ResponseClass != null)
            {
                JsonSerializer.Serialize(writer, value.ResponseClass, options);
                return;
            }
            throw new Exception("Cannot marshal type Response");
        }

        public static readonly PostmanResponseConverter Singleton = new PostmanResponseConverter();
    }

    internal class PostmanLanguageConverter : JsonConverter<PostmanLanguage>
    {
        public override bool CanConvert(Type t) => t == typeof(PostmanLanguage);

        public override PostmanLanguage Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "Text":
                    return PostmanLanguage.Text;
                case "html":
                    return PostmanLanguage.Html;
                case "javascript":
                    return PostmanLanguage.Javascript;
                case "xml":
                    return PostmanLanguage.Xml;
            }
            throw new Exception("Cannot unmarshal type Language");
        }

        public override void Write(Utf8JsonWriter writer, PostmanLanguage value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case PostmanLanguage.Text:
                    JsonSerializer.Serialize(writer, "Text", options);
                    return;
                case PostmanLanguage.Html:
                    JsonSerializer.Serialize(writer, "html", options);
                    return;
                case PostmanLanguage.Javascript:
                    JsonSerializer.Serialize(writer, "javascript", options);
                    return;
                case PostmanLanguage.Xml:
                    JsonSerializer.Serialize(writer, "xml", options);
                    return;
            }
            throw new Exception("Cannot marshal type Language");
        }

        public static readonly PostmanLanguageConverter Singleton = new PostmanLanguageConverter();
    }

    internal class PostmanTimeConverter : JsonConverter<PostmanTime>
    {
        public override bool CanConvert(Type t) => t == typeof(PostmanTime);

        public override PostmanTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new PostmanTime { };
                case JsonTokenType.Number:
                    var doubleValue = reader.GetDouble();
                    return new PostmanTime { Double = doubleValue };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new PostmanTime { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type Time");
        }

        public override void Write(Utf8JsonWriter writer, PostmanTime value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.Double != null)
            {
                JsonSerializer.Serialize(writer, value.Double.Value, options);
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            throw new Exception("Cannot marshal type Time");
        }

        public static readonly PostmanTimeConverter Singleton = new PostmanTimeConverter();
    }
    
    public class PostmanDateOnlyConverter : JsonConverter<DateOnly>
    {
        private readonly string serializationFormat;
        public PostmanDateOnlyConverter() : this(null) { }

        public PostmanDateOnlyConverter(string? serializationFormat)
        {
            this.serializationFormat = serializationFormat ?? "yyyy-MM-dd";
        }

        public override DateOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            return DateOnly.Parse(value!);
        }

        public override void Write(Utf8JsonWriter writer, DateOnly value, JsonSerializerOptions options)
            => writer.WriteStringValue(value.ToString(serializationFormat));
    }

    public class PostmanTimeOnlyConverter : JsonConverter<TimeOnly>
    {
        private readonly string serializationFormat;

        public PostmanTimeOnlyConverter() : this(null) { }

        public PostmanTimeOnlyConverter(string? serializationFormat)
        {
            this.serializationFormat = serializationFormat ?? "HH:mm:ss.fff";
        }

        public override TimeOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            return TimeOnly.Parse(value!);
        }

        public override void Write(Utf8JsonWriter writer, TimeOnly value, JsonSerializerOptions options)
            => writer.WriteStringValue(value.ToString(serializationFormat));
    }

    internal class PostmanIsoDateTimeOffsetConverter : JsonConverter<DateTimeOffset>
    {
        public override bool CanConvert(Type t) => t == typeof(DateTimeOffset);

        private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

        private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;
        private string? _dateTimeFormat;
        private CultureInfo? _culture;

        public DateTimeStyles DateTimeStyles
        {
            get => _dateTimeStyles;
            set => _dateTimeStyles = value;
        }

        public string? DateTimeFormat
        {
            get => _dateTimeFormat ?? string.Empty;
            set => _dateTimeFormat = (string.IsNullOrEmpty(value)) ? null : value;
        }

        public CultureInfo Culture
        {
            get => _culture ?? CultureInfo.CurrentCulture;
            set => _culture = value;
        }

        public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
        {
            string text;


            if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal
                || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
            {
                value = value.ToUniversalTime();
            }

            text = value.ToString(_dateTimeFormat ?? DefaultDateTimeFormat, Culture);

            writer.WriteStringValue(text);
        }

        public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            string? dateText = reader.GetString();

            if (string.IsNullOrEmpty(dateText) == false)
            {
                if (!string.IsNullOrEmpty(_dateTimeFormat))
                {
                    return DateTimeOffset.ParseExact(dateText, _dateTimeFormat, Culture, _dateTimeStyles);
                }
                else
                {
                    return DateTimeOffset.Parse(dateText, Culture, _dateTimeStyles);
                }
            }
            else
            {
                return default(DateTimeOffset);
            }
        }


        public static readonly PostmanIsoDateTimeOffsetConverter Singleton = new PostmanIsoDateTimeOffsetConverter();
    }
}
#pragma warning restore CS8618
#pragma warning restore CS8601
#pragma warning restore CS8603
#pragma warning restore CS1591
