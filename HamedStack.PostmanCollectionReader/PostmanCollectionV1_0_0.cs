// <auto-generated />

#nullable enable
#pragma warning disable CS8618
#pragma warning disable CS8601
#pragma warning disable CS8603
#pragma warning disable CS1591

namespace HamedStack.PostmanCollectionV1_0_0
{
    using System;
    using System.Collections.Generic;

    using System.Text.Json;
    using System.Text.Json.Serialization;
    using System.Globalization;

    public partial class PostmanCollection1_0_0
    {
        [JsonPropertyName("auth")]
        public Auth Auth { get; set; }

        /// <summary>
        /// Provide a long description of this collection using this field. This field supports
        /// markdown syntax to better format the description.
        /// </summary>
        [JsonPropertyName("description")]
        public string Description { get; set; }

        [JsonPropertyName("events")]
        public Event[] Events { get; set; }

        /// <summary>
        /// Folders are the way to go if you want to group your requests and to keep things
        /// organised. Folders can also be useful in sequentially requesting a part of the entire
        /// collection by using [Postman Collection
        /// Runner](https://www.getpostman.com/docs/jetpacks_running_collections) or
        /// [Newman](https://github.com/postmanlabs/newman) on a particular folder.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("folders")]
        public Folder[] Folders { get; set; }

        /// <summary>
        /// The folders order array ensures that your requests and folders don't randomly get
        /// shuffled up. It holds a sequence of
        /// [UUIDs](https://en.wikipedia.org/wiki/Universally_unique_identifier) corresponding to
        /// folders and requests.
        /// *Note that if a folder ID or a request ID (if the request is not already part of a
        /// folder) is not included in the order array, the request or the folder will not show up in
        /// the collection.*
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("folders_order")]
        public string[] FoldersOrder { get; set; }

        /// <summary>
        /// Every collection is identified by the unique value of this field. The value of this field
        /// is usually easiest to generate using a
        /// [UID](https://tools.ietf.org/html/rfc4122#section-4.4%29) generator function. If you
        /// already have a collection, it is recommended that you maintain the same id since changing
        /// the id usually implies that this is a different collection than it was originally.
        /// </summary>
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// A collection's friendly name is defined by this field. You would want to set this field
        /// to a value that would allow you to easily identify this collection among a bunch of other
        /// collections, as such outlining its usage or content.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// The order array ensures that your requests and folders don't randomly get shuffled up. It
        /// holds a sequence of [UUIDs](https://en.wikipedia.org/wiki/Universally_unique_identifier)
        /// corresponding to folders and requests.
        /// *Note that if a folder ID or a request ID (if the request is not already part of a
        /// folder) is not included in the order array, the request or the folder will not show up in
        /// the collection.*
        /// </summary>
        [JsonPropertyName("order")]
        public string[] Order { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("protocolProfileBehavior")]
        public Dictionary<string, object> ProtocolProfileBehavior { get; set; }

        [JsonPropertyName("requests")]
        public Request[] Requests { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("timestamp")]
        public double? Timestamp { get; set; }

        [JsonPropertyName("variables")]
        public Variable[] Variables { get; set; }
    }

    /// <summary>
    /// Represents authentication helpers provided by Postman
    /// </summary>
    public partial class Auth
    {
        /// <summary>
        /// The attributes for API Key Authentication
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("apikey")]
        public ApikeyElement[] Apikey { get; set; }

        /// <summary>
        /// The attributes for [AWS
        /// Auth](http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html).
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("awsv4")]
        public ApikeyElement[] Awsv4 { get; set; }

        /// <summary>
        /// The attributes for [Basic
        /// Authentication](https://en.wikipedia.org/wiki/Basic_access_authentication).
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("basic")]
        public ApikeyElement[] Basic { get; set; }

        /// <summary>
        /// The helper attributes for [Bearer Token
        /// Authentication](https://tools.ietf.org/html/rfc6750)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("bearer")]
        public ApikeyElement[] Bearer { get; set; }

        /// <summary>
        /// The attributes for [Digest
        /// Authentication](https://en.wikipedia.org/wiki/Digest_access_authentication).
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("digest")]
        public ApikeyElement[] Digest { get; set; }

        /// <summary>
        /// The attributes for [Akamai EdgeGrid
        /// Authentication](https://developer.akamai.com/legacy/introduction/Client_Auth.html).
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("edgegrid")]
        public ApikeyElement[] Edgegrid { get; set; }

        /// <summary>
        /// The attributes for [Hawk Authentication](https://github.com/hueniverse/hawk)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("hawk")]
        public ApikeyElement[] Hawk { get; set; }

        [JsonPropertyName("noauth")]
        public object Noauth { get; set; }

        /// <summary>
        /// The attributes for [NTLM
        /// Authentication](https://msdn.microsoft.com/en-us/library/cc237488.aspx)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("ntlm")]
        public ApikeyElement[] Ntlm { get; set; }

        /// <summary>
        /// The attributes for [OAuth2](https://oauth.net/1/)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("oauth1")]
        public ApikeyElement[] Oauth1 { get; set; }

        /// <summary>
        /// Helper attributes for [OAuth2](https://oauth.net/2/)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("oauth2")]
        public ApikeyElement[] Oauth2 { get; set; }

        [JsonPropertyName("type")]
        public AuthType Type { get; set; }
    }

    /// <summary>
    /// Represents an attribute for any authorization method provided by Postman. For example
    /// `username` and `password` are set as auth attributes for Basic Authentication method.
    /// </summary>
    public partial class ApikeyElement
    {
        [JsonPropertyName("key")]
        public string Key { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public string Type { get; set; }

        [JsonPropertyName("value")]
        public object Value { get; set; }
    }

    /// <summary>
    /// Defines a script associated with an associated event name
    /// </summary>
    public partial class Event
    {
        /// <summary>
        /// Indicates whether the event is disabled. If absent, the event is assumed to be enabled.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("disabled")]
        public bool? Disabled { get; set; }

        /// <summary>
        /// A unique identifier for the enclosing event.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Can be set to `test` or `prerequest` for test scripts or pre-request scripts respectively.
        /// </summary>
        [JsonPropertyName("listen")]
        public string Listen { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("script")]
        public Script Script { get; set; }
    }

    /// <summary>
    /// A script is a snippet of Javascript code that can be used to to perform setup or teardown
    /// operations on a particular response.
    /// </summary>
    public partial class Script
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("exec")]
        public Host? Exec { get; set; }

        /// <summary>
        /// A unique, user defined identifier that can  be used to refer to this script from requests.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Script name
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("name")]
        public string Name { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("src")]
        public Url? Src { get; set; }

        /// <summary>
        /// Type of the script. E.g: 'text/javascript'
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public string Type { get; set; }
    }

    public partial class UrlClass
    {
        /// <summary>
        /// Contains the URL fragment (if any). Usually this is not transmitted over the network, but
        /// it could be useful to store this in some cases.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("hash")]
        public string Hash { get; set; }

        /// <summary>
        /// The host for the URL, E.g: api.yourdomain.com. Can be stored as a string or as an array
        /// of strings.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("host")]
        public Host? Host { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("path")]
        public UrlPath? Path { get; set; }

        /// <summary>
        /// The port number present in this URL. An empty value implies 80/443 depending on whether
        /// the protocol field contains http/https.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("port")]
        public string Port { get; set; }

        /// <summary>
        /// The protocol associated with the request, E.g: 'http'
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("protocol")]
        public string Protocol { get; set; }

        /// <summary>
        /// An array of QueryParams, which is basically the query string part of the URL, parsed into
        /// separate variables
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("query")]
        public QueryParam[] Query { get; set; }

        /// <summary>
        /// The string representation of the request URL, including the protocol, host, path, hash,
        /// query parameter(s) and path variable(s).
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("raw")]
        public string Raw { get; set; }

        /// <summary>
        /// Postman supports path variables with the syntax `/path/:variableName/to/somewhere`. These
        /// variables are stored in this field.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("variable")]
        public Variable[] Variable { get; set; }
    }

    public partial class PathClass
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public string Type { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("value")]
        public string Value { get; set; }
    }

    public partial class QueryParam
    {
        [JsonPropertyName("description")]
        public DescriptionUnion? Description { get; set; }

        /// <summary>
        /// If set to true, the current query parameter will not be sent with the request.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("disabled")]
        public bool? Disabled { get; set; }

        [JsonPropertyName("key")]
        public string Key { get; set; }

        [JsonPropertyName("value")]
        public string Value { get; set; }
    }

    public partial class Description
    {
        /// <summary>
        /// The content of the description goes here, as a raw string.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("content")]
        public string Content { get; set; }

        /// <summary>
        /// Holds the mime type of the raw description content. E.g: 'text/markdown' or 'text/html'.
        /// The type is used to correctly render the description when generating documentation, or in
        /// the Postman app.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public string Type { get; set; }

        /// <summary>
        /// Description can have versions associated with it, which should be put in this property.
        /// </summary>
        [JsonPropertyName("version")]
        public object Version { get; set; }
    }

    /// <summary>
    /// Collection variables allow you to define a set of variables, that are a *part of the
    /// collection*, as opposed to environments, which are separate entities.
    /// *Note: Collection variables must not contain any sensitive information.*
    ///
    /// Using variables in your Postman requests eliminates the need to duplicate requests, which
    /// can save a lot of time. Variables can be defined, and referenced to from any part of a
    /// request.
    /// </summary>
    public partial class Variable
    {
        [JsonPropertyName("description")]
        public DescriptionUnion? Description { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("disabled")]
        public bool? Disabled { get; set; }

        /// <summary>
        /// A variable ID is a unique user-defined value that identifies the variable within a
        /// collection. In traditional terms, this would be a variable name.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// A variable key is a human friendly value that identifies the variable within a
        /// collection. In traditional terms, this would be a variable name.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("key")]
        public string Key { get; set; }

        /// <summary>
        /// Variable name
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// When set to true, indicates that this variable has been set by Postman
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("system")]
        public bool? System { get; set; }

        /// <summary>
        /// A variable may have multiple types. This field specifies the type of the variable.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public VariableType? Type { get; set; }

        /// <summary>
        /// The value that a variable holds in this collection. Ultimately, the variables will be
        /// replaced by this value, when say running a set of requests from a collection
        /// </summary>
        [JsonPropertyName("value")]
        public object Value { get; set; }
    }

    /// <summary>
    /// One of the primary goals of Postman is to organize the development of APIs. To this end,
    /// it is necessary to be able to group requests together. This can be achived using
    /// 'Folders'. A folder just is an ordered set of requests.
    /// </summary>
    public partial class Folder
    {
        [JsonPropertyName("auth")]
        public Auth Auth { get; set; }

        /// <summary>
        /// Postman folders are always a part of a collection. That collection's unique ID (which is
        /// a [UUID](https://en.wikipedia.org/wiki/Globally_unique_identifier)) is stored in this
        /// field.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("collection")]
        public string Collection { get; set; }

        /// <summary>
        /// Postman folders are always a part of a collection. That collection's unique ID (which is
        /// a [UUID](https://en.wikipedia.org/wiki/Globally_unique_identifier)) is stored in this
        /// field.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("collection_id")]
        public string CollectionId { get; set; }

        /// <summary>
        /// Essays about the folder go into this field!
        /// </summary>
        [JsonPropertyName("description")]
        public string Description { get; set; }

        [JsonPropertyName("events")]
        public Event[] Events { get; set; }

        /// <summary>
        /// Postman preserves the order of your folders within each folder. This field holds a
        /// sequence of [UUIDs](https://en.wikipedia.org/wiki/Globally_unique_identifier), where each
        /// ID corresponds to a particular collection folder.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("folders_order")]
        public string[] FoldersOrder { get; set; }

        /// <summary>
        /// In order to be able to uniquely identify different folders within a collection, Postman
        /// assigns each folder a unique ID (a
        /// [UUID](https://en.wikipedia.org/wiki/Globally_unique_identifier)). This field contains
        /// that value.
        /// </summary>
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// A folder's friendly name is defined by this field. You would want to set this field to a
        /// value that would allow you to easily identify this folder.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// Postman preserves the order of your requests within each folder. This field holds a
        /// sequence of [UUIDs](https://en.wikipedia.org/wiki/Globally_unique_identifier), where each
        /// ID corresponds to a particular Postman request.
        /// </summary>
        [JsonPropertyName("order")]
        public string[] Order { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("protocolProfileBehavior")]
        public Dictionary<string, object> ProtocolProfileBehavior { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("variables")]
        public Variable[] Variables { get; set; }
    }

    /// <summary>
    /// A request represents an HTTP request.
    /// </summary>
    public partial class Request
    {
        [JsonPropertyName("auth")]
        public Auth Auth { get; set; }

        /// <summary>
        /// This field contains the unique ID of the collection to which this request belongs.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("collection")]
        public string Collection { get; set; }

        /// <summary>
        /// This field contains the unique ID of the collection to which this request belongs.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("collectionId")]
        public string CollectionId { get; set; }

        [JsonPropertyName("currentHelper")]
        public string CurrentHelper { get; set; }

        [JsonPropertyName("data")]
        public Datum[] Data { get; set; }

        /// <summary>
        /// When set to true, prevents request body from being sent.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("dataDisabled")]
        public bool? DataDisabled { get; set; }

        [JsonPropertyName("dataMode")]
        public DataMode? DataMode { get; set; }

        /// <summary>
        /// Additional configurations and options set for various body modes.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("dataOptions")]
        public Dictionary<string, object> DataOptions { get; set; }

        /// <summary>
        /// The description of this request. Can be as long as you want. Postman also supports two
        /// formats for your description, ``markdown`` and ``html``.
        /// </summary>
        [JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// A request can have an associated description text. Since description is meant to be long,
        /// it can be in either ``html`` or ``markdown`` formats. This field specifies that format.
        /// </summary>
        [JsonPropertyName("descriptionFormat")]
        public DescriptionFormat? DescriptionFormat { get; set; }

        [JsonPropertyName("events")]
        public Event[] Events { get; set; }

        /// <summary>
        /// Postman requests may or may not be a part of a folder. If this request belongs to a
        /// folder, that folder's unique ID (which is a
        /// [UUID](https://en.wikipedia.org/wiki/Globally_unique_identifier)) is stored in this field.
        /// </summary>
        [JsonPropertyName("folder")]
        public string Folder { get; set; }

        /// <summary>
        /// This field contains the GraphQL request body
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("graphqlModeData")]
        public Dictionary<string, object> GraphqlModeData { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("headerData")]
        public Header[] HeaderData { get; set; }

        /// <summary>
        /// No HTTP request is complete without its headers, and the same is true for a Postman
        /// request. This field contains all the HTTP Headers in a raw string format.
        /// </summary>
        [JsonPropertyName("headers")]
        public string Headers { get; set; }

        [JsonPropertyName("helperAttributes")]
        public HelperAttributes? HelperAttributes { get; set; }

        /// <summary>
        /// Postman can store a number of requests in each collection. In order to preserve the order
        /// of each request, we need to be able to identify requests uniquely. This field is a UUID
        /// assigned to each request.
        /// </summary>
        [JsonPropertyName("id")]
        public string Id { get; set; }

        [JsonPropertyName("method")]
        public string Method { get; set; }

        /// <summary>
        /// Sometimes, you just need to call your request 'Bob'. Postman will let you do that, and
        /// store the name you give in this field.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pathVariableData")]
        public PathVariable[] PathVariableData { get; set; }

        /// <summary>
        /// A Postman request allows you to use Path Variables in a request, e.g:
        /// ``/search/:bookId``. This field stores these variables.
        /// </summary>
        [JsonPropertyName("pathVariables")]
        public PathVariables? PathVariables { get; set; }

        [JsonPropertyName("preRequestScript")]
        public string PreRequestScript { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("protocolProfileBehavior")]
        public Dictionary<string, object> ProtocolProfileBehavior { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("queryParams")]
        public UrlParam[] QueryParams { get; set; }

        /// <summary>
        /// Contains the raw data (parameters) that Postman sends to the server
        /// </summary>
        [JsonPropertyName("rawModeData")]
        public Value? RawModeData { get; set; }

        /// <summary>
        /// A Postman request can have multiple responses associated with it. These responses are
        /// stored in this field.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("responses")]
        public Response[] Responses { get; set; }

        /// <summary>
        /// Postman preserves the order of your responses within each request. This field holds a
        /// sequence of [UUIDs](https://en.wikipedia.org/wiki/Globally_unique_identifier), where each
        /// ID corresponds to a particular response.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("responses_order")]
        public string[] ResponsesOrder { get; set; }

        [JsonPropertyName("tests")]
        public string Tests { get; set; }

        /// <summary>
        /// The timestamp for this request.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("time")]
        public double? Time { get; set; }

        /// <summary>
        /// Contains the complete URL for this request, along with the path variables, if any.
        /// </summary>
        [JsonPropertyName("url")]
        public string Url { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("variables")]
        public Variable[] Variables { get; set; }
    }

    /// <summary>
    /// Data is an array of key-values that the request goes with. POST data, PUT data, etc goes
    /// here.
    /// </summary>
    public partial class Datum
    {
        /// <summary>
        /// Override Content-Type header of this form data entity.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("contentType")]
        public string ContentType { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("description")]
        public string Description { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("enabled")]
        public bool? Enabled { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("key")]
        public string Key { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public DatumType? Type { get; set; }

        [JsonPropertyName("value")]
        public Value? Value { get; set; }
    }

    public partial class HeaderClass
    {
        /// <summary>
        /// You can associate descriptions with headers too.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// Name of the header goes here. e.g: `Content-Type`
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("key")]
        public string Key { get; set; }

        /// <summary>
        /// The value of the header
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("value")]
        public string Value { get; set; }
    }

    /// <summary>
    /// The attributes for API Key Authentication. e.g. key, value, in.
    ///
    /// The attributes for [AWS
    /// Auth](http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html). e.g.
    /// accessKey, secretKey, region, service.
    ///
    /// The attributes for [Digest
    /// Authentication](https://en.wikipedia.org/wiki/Digest_access_authentication). e.g.
    /// username, password, realm, nonce, nonceCount, algorithm, qop, opaque, clientNonce.
    ///
    /// The attributes for [Akamai EdgeGrid
    /// Authentication](https://developer.akamai.com/legacy/introduction/Client_Auth.html). e.g.
    /// accessToken, clientToken, clientSecret, baseURL, nonce, timestamp, headersToSign.
    ///
    /// The attributes for [Hawk Authentication](https://github.com/hueniverse/hawk). e.g.
    /// authId, authKey, algorith, user, nonce, extraData, appId, delegation, timestamp.
    ///
    /// The attributes for [NTLM
    /// Authentication](https://msdn.microsoft.com/en-us/library/cc237488.aspx). e.g. username,
    /// password, domain, workstation.
    ///
    /// The attributes for [Basic
    /// Authentication](https://en.wikipedia.org/wiki/Basic_access_authentication). e.g.
    /// username, password.
    ///
    /// The attributes for [Bearer Token Authentication](https://tools.ietf.org/html/rfc6750).
    /// e.g. token.
    ///
    /// The attributes for [OAuth1](https://oauth.net/1/). e.g. consumerKey, consumerSecret,
    /// token, tokenSecret, signatureMethod, timestamp, nonce, version, realm, encodeOAuthSign.
    ///
    /// The attributes for [OAuth2](https://oauth.net/2/). e.g. accessToken, addTokenTo.
    /// </summary>
    public partial class ApiKeyAuthentication
    {
        /// <summary>
        /// This field contains the type of the helper. In this case, it is ``apikey``
        ///
        /// This field contains the type of the helper. In this case, it is ``awsSigV4``
        ///
        /// This field contains the type of the helper. In this case, it is ``digest``
        ///
        /// This field contains the type of the helper. In this case, it is ``edgegrid``
        ///
        /// This field contains the type of the Postman helper. In this case, it is ``hawk``
        ///
        /// This field contains the type of the helper. In this case, it is ``ntlm``
        ///
        /// This field contains the type of the helper. In this case, it is ``basic``
        ///
        /// This field contains the type of the helper. In this case, it is ``bearer``
        ///
        /// This field contains the type of the helper. In this case, it is ``oAuth1``
        ///
        /// This field contains the type of the helper. In this case, it is ``oAuth2``
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("id")]
        public Id? Id { get; set; }
    }

    public partial class PathVariableClass
    {
        /// <summary>
        /// Extra description about a path variable may be added in this field.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// The identifier of a path variable goes here.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("key")]
        public string Key { get; set; }

        /// <summary>
        /// The value of the path variable will be substituted in place of the key.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("value")]
        public string Value { get; set; }
    }

    public partial class UrlParamClass
    {
        /// <summary>
        /// You can associate descriptions with URL parameters, which are stored in this field.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// The key of a URL parameter.
        /// </summary>
        [JsonPropertyName("key")]
        public string Key { get; set; }

        /// <summary>
        /// The value of a URL parameter
        /// </summary>
        [JsonPropertyName("value")]
        public string Value { get; set; }
    }

    public partial class ResponseClass
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("cookies")]
        public Cookie[] Cookies { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("headers")]
        public HeaderElement[] Headers { get; set; }

        /// <summary>
        /// In order to unambiguously identify a response, Postman assigns a UUID to it, and stores
        /// it in this field.
        /// </summary>
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// The language associated with the response.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("language")]
        public Language? Language { get; set; }

        /// <summary>
        /// Mimetype of the response.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("mime")]
        public string Mime { get; set; }

        /// <summary>
        /// A response can have a friendly name, which goes here.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// The data type of the raw response.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("rawDataType")]
        public string RawDataType { get; set; }

        /// <summary>
        /// A response is associated with a request. This fields contains the UUID of the request
        /// corresponding to this response.
        /// </summary>
        [JsonPropertyName("request")]
        public PathVariables Request { get; set; }

        [JsonPropertyName("responseCode")]
        public ResponseCode ResponseCode { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("status")]
        public string Status { get; set; }

        /// <summary>
        /// The raw text of the response.
        /// </summary>
        [JsonPropertyName("text")]
        public string Text { get; set; }

        /// <summary>
        /// The time taken by this particular HTTP transaction to complete is stored in this field.
        /// For manually created responses, this field can be set to ``null``.
        /// </summary>
        [JsonPropertyName("time")]
        public Time? Time { get; set; }

        /// <summary>
        /// Set of timing information related to request and response in milliseconds
        /// </summary>
        [JsonPropertyName("timings")]
        public Dictionary<string, object> Timings { get; set; }
    }

    public partial class Cookie
    {
        /// <summary>
        /// The domain for which this cookie is valid.
        /// </summary>
        [JsonPropertyName("domain")]
        public string Domain { get; set; }

        /// <summary>
        /// The timestamp of the time when the cookie expires.
        /// </summary>
        [JsonPropertyName("expirationDate")]
        public double ExpirationDate { get; set; }

        /// <summary>
        /// Human readable expiration time.
        /// </summary>
        [JsonPropertyName("expires")]
        public string Expires { get; set; }

        /// <summary>
        /// Indicates if this cookie is Host Only.
        /// </summary>
        [JsonPropertyName("hostOnly")]
        public bool HostOnly { get; set; }

        /// <summary>
        /// Indicates if this cookie is HTTP Only.
        /// </summary>
        [JsonPropertyName("httpOnly")]
        public bool HttpOnly { get; set; }

        /// <summary>
        /// This is the name of the Cookie.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// The path associated with the Cookie.
        /// </summary>
        [JsonPropertyName("path")]
        public string Path { get; set; }

        /// <summary>
        /// Indicates if the 'secure' flag is set on the Cookie.
        /// </summary>
        [JsonPropertyName("secure")]
        public bool Secure { get; set; }

        /// <summary>
        /// True if the cookie is a session cookie.
        /// </summary>
        [JsonPropertyName("session")]
        public bool Session { get; set; }

        /// <summary>
        /// The ID of the cookie store containing this cookie.
        /// </summary>
        [JsonPropertyName("storeId")]
        public string StoreId { get; set; }

        /// <summary>
        /// The value of the Cookie.
        /// </summary>
        [JsonPropertyName("value")]
        public string Value { get; set; }
    }

    public partial class HeaderElement
    {
        /// <summary>
        /// An optional description about the header.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// The left hand side (LHS) or 'key' of the header.
        /// </summary>
        [JsonPropertyName("key")]
        public string Key { get; set; }

        /// <summary>
        /// Some headers can have names associated with them, which are stored in this field.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// Value of the header, or the right hand side (RHS).
        /// </summary>
        [JsonPropertyName("value")]
        public string Value { get; set; }
    }

    public partial class ResponseCode
    {
        /// <summary>
        /// The numeric HTTP response code.
        /// </summary>
        [JsonPropertyName("code")]
        public double Code { get; set; }

        /// <summary>
        /// Detailed explanation of the response code.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("detail")]
        public string Detail { get; set; }

        /// <summary>
        /// The textual HTTP response code.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; }
    }

    public enum AuthType { Apikey, Awsv4, Basic, Bearer, Digest, Edgegrid, Hawk, Noauth, Ntlm, Oauth1, Oauth2 };

    /// <summary>
    /// A variable may have multiple types. This field specifies the type of the variable.
    /// </summary>
    public enum VariableType { Any, Boolean, Number, String };

    public enum DatumType { File, Text };

    /// <summary>
    /// A request can have a specific data mode, and Postman supports these.
    /// </summary>
    public enum DataMode { Binary, Graphql, Params, Raw, Urlencoded };

    public enum DescriptionFormat { Html, Markdown };

    /// <summary>
    /// This field contains the type of the helper. In this case, it is ``apikey``
    /// </summary>
    public enum Id { Apikey, AwsSigV4, Basic, Bearer, Digest, Edgegrid, Hawk, Ntlm, OAuth1, OAuth2 };

    /// <summary>
    /// The language associated with the response.
    /// </summary>
    public enum Language { Html, Javascript, Text, Xml };

    /// <summary>
    /// The host for the URL, E.g: api.yourdomain.com. Can be stored as a string or as an array
    /// of strings.
    /// </summary>
    public partial struct Host
    {
        public string String;
        public string[] StringArray;

        public static implicit operator Host(string String) => new Host { String = String };
        public static implicit operator Host(string[] StringArray) => new Host { StringArray = StringArray };
    }

    /// <summary>
    /// The complete path of the current url, broken down into segments. A segment could be a
    /// string, or a path variable.
    /// </summary>
    public partial struct PathElement
    {
        public PathClass PathClass;
        public string String;

        public static implicit operator PathElement(PathClass PathClass) => new PathElement { PathClass = PathClass };
        public static implicit operator PathElement(string String) => new PathElement { String = String };
    }

    public partial struct UrlPath
    {
        public PathElement[] AnythingArray;
        public string String;

        public static implicit operator UrlPath(PathElement[] AnythingArray) => new UrlPath { AnythingArray = AnythingArray };
        public static implicit operator UrlPath(string String) => new UrlPath { String = String };
    }

    /// <summary>
    /// A Description can be a raw text, or be an object, which holds the description along with
    /// its format.
    /// </summary>
    public partial struct DescriptionUnion
    {
        public Description Description;
        public string String;

        public static implicit operator DescriptionUnion(Description Description) => new DescriptionUnion { Description = Description };
        public static implicit operator DescriptionUnion(string String) => new DescriptionUnion { String = String };
        public bool IsNull => Description == null && String == null;
    }

    /// <summary>
    /// If object, contains the complete broken-down URL for this request. If string, contains
    /// the literal request URL.
    /// </summary>
    public partial struct Url
    {
        public string String;
        public UrlClass UrlClass;

        public static implicit operator Url(string String) => new Url { String = String };
        public static implicit operator Url(UrlClass UrlClass) => new Url { UrlClass = UrlClass };
    }

    /// <summary>
    /// Contains the raw data (parameters) that Postman sends to the server
    /// </summary>
    public partial struct Value
    {
        public object[] AnythingArray;
        public string String;

        public static implicit operator Value(object[] AnythingArray) => new Value { AnythingArray = AnythingArray };
        public static implicit operator Value(string String) => new Value { String = String };
        public bool IsNull => AnythingArray == null && String == null;
    }

    /// <summary>
    /// A response represents an HTTP response.
    /// </summary>
    public partial struct Header
    {
        public object[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public HeaderClass HeaderClass;
        public long? Integer;
        public string String;

        public static implicit operator Header(object[] AnythingArray) => new Header { AnythingArray = AnythingArray };
        public static implicit operator Header(bool Bool) => new Header { Bool = Bool };
        public static implicit operator Header(double Double) => new Header { Double = Double };
        public static implicit operator Header(HeaderClass HeaderClass) => new Header { HeaderClass = HeaderClass };
        public static implicit operator Header(long Integer) => new Header { Integer = Integer };
        public static implicit operator Header(string String) => new Header { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && HeaderClass == null && Double == null && Integer == null && String == null;
    }

    /// <summary>
    /// A helper may require a number of parameters to actually be helpful. The parameters used
    /// by the helper can be stored in this field, as an object. E.g when using Basic
    /// Authentication, the username and password will be stored here.
    /// </summary>
    public partial struct HelperAttributes
    {
        public ApiKeyAuthentication ApiKeyAuthentication;
        public string String;

        public static implicit operator HelperAttributes(ApiKeyAuthentication ApiKeyAuthentication) => new HelperAttributes { ApiKeyAuthentication = ApiKeyAuthentication };
        public static implicit operator HelperAttributes(string String) => new HelperAttributes { String = String };
        public bool IsNull => ApiKeyAuthentication == null && String == null;
    }

    /// <summary>
    /// A request URL may contain one or more path variables (e.g: `:varname`)
    /// </summary>
    public partial struct PathVariable
    {
        public object[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public long? Integer;
        public PathVariableClass PathVariableClass;
        public string String;

        public static implicit operator PathVariable(object[] AnythingArray) => new PathVariable { AnythingArray = AnythingArray };
        public static implicit operator PathVariable(bool Bool) => new PathVariable { Bool = Bool };
        public static implicit operator PathVariable(double Double) => new PathVariable { Double = Double };
        public static implicit operator PathVariable(long Integer) => new PathVariable { Integer = Integer };
        public static implicit operator PathVariable(PathVariableClass PathVariableClass) => new PathVariable { PathVariableClass = PathVariableClass };
        public static implicit operator PathVariable(string String) => new PathVariable { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && PathVariableClass == null && Double == null && Integer == null && String == null;
    }

    /// <summary>
    /// A Postman request allows you to use Path Variables in a request, e.g:
    /// ``/search/:bookId``. This field stores these variables.
    ///
    /// A response is associated with a request. This fields contains the UUID of the request
    /// corresponding to this response.
    /// </summary>
    public partial struct PathVariables
    {
        public Dictionary<string, object> AnythingMap;
        public string String;

        public static implicit operator PathVariables(Dictionary<string, object> AnythingMap) => new PathVariables { AnythingMap = AnythingMap };
        public static implicit operator PathVariables(string String) => new PathVariables { String = String };
        public bool IsNull => AnythingMap == null && String == null;
    }

    /// <summary>
    /// A response represents an HTTP response.
    /// </summary>
    public partial struct UrlParam
    {
        public object[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public long? Integer;
        public string String;
        public UrlParamClass UrlParamClass;

        public static implicit operator UrlParam(object[] AnythingArray) => new UrlParam { AnythingArray = AnythingArray };
        public static implicit operator UrlParam(bool Bool) => new UrlParam { Bool = Bool };
        public static implicit operator UrlParam(double Double) => new UrlParam { Double = Double };
        public static implicit operator UrlParam(long Integer) => new UrlParam { Integer = Integer };
        public static implicit operator UrlParam(string String) => new UrlParam { String = String };
        public static implicit operator UrlParam(UrlParamClass UrlParamClass) => new UrlParam { UrlParamClass = UrlParamClass };
        public bool IsNull => AnythingArray == null && Bool == null && UrlParamClass == null && Double == null && Integer == null && String == null;
    }

    /// <summary>
    /// The time taken by this particular HTTP transaction to complete is stored in this field.
    /// For manually created responses, this field can be set to ``null``.
    /// </summary>
    public partial struct Time
    {
        public double? Double;
        public string String;

        public static implicit operator Time(double Double) => new Time { Double = Double };
        public static implicit operator Time(string String) => new Time { String = String };
        public bool IsNull => Double == null && String == null;
    }

    /// <summary>
    /// A response represents an HTTP response.
    /// </summary>
    public partial struct Response
    {
        public object[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public long? Integer;
        public ResponseClass ResponseClass;
        public string String;

        public static implicit operator Response(object[] AnythingArray) => new Response { AnythingArray = AnythingArray };
        public static implicit operator Response(bool Bool) => new Response { Bool = Bool };
        public static implicit operator Response(double Double) => new Response { Double = Double };
        public static implicit operator Response(long Integer) => new Response { Integer = Integer };
        public static implicit operator Response(ResponseClass ResponseClass) => new Response { ResponseClass = ResponseClass };
        public static implicit operator Response(string String) => new Response { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && ResponseClass == null && Double == null && Integer == null && String == null;
    }

    public partial class PostmanCollection1_0_0
    {
        public static PostmanCollection1_0_0 FromJson(string json) => JsonSerializer.Deserialize<PostmanCollection1_0_0>(json, PostmanCollectionV1_0_0.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this PostmanCollection1_0_0 self) => JsonSerializer.Serialize(self, PostmanCollectionV1_0_0.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerOptions Settings = new(JsonSerializerDefaults.General)
        {
            Converters =
            {
                AuthTypeConverter.Singleton,
                HostConverter.Singleton,
                UrlConverter.Singleton,
                UrlPathConverter.Singleton,
                PathElementConverter.Singleton,
                DescriptionUnionConverter.Singleton,
                VariableTypeConverter.Singleton,
                DatumTypeConverter.Singleton,
                ValueConverter.Singleton,
                DataModeConverter.Singleton,
                DescriptionFormatConverter.Singleton,
                HeaderConverter.Singleton,
                HelperAttributesConverter.Singleton,
                IdConverter.Singleton,
                PathVariableConverter.Singleton,
                PathVariablesConverter.Singleton,
                UrlParamConverter.Singleton,
                ResponseConverter.Singleton,
                LanguageConverter.Singleton,
                TimeConverter.Singleton,
                new DateOnlyConverter(),
                new TimeOnlyConverter(),
                IsoDateTimeOffsetConverter.Singleton
            },
        };
    }

    internal class AuthTypeConverter : JsonConverter<AuthType>
    {
        public override bool CanConvert(Type t) => t == typeof(AuthType);

        public override AuthType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "apikey":
                    return AuthType.Apikey;
                case "awsv4":
                    return AuthType.Awsv4;
                case "basic":
                    return AuthType.Basic;
                case "bearer":
                    return AuthType.Bearer;
                case "digest":
                    return AuthType.Digest;
                case "edgegrid":
                    return AuthType.Edgegrid;
                case "hawk":
                    return AuthType.Hawk;
                case "noauth":
                    return AuthType.Noauth;
                case "ntlm":
                    return AuthType.Ntlm;
                case "oauth1":
                    return AuthType.Oauth1;
                case "oauth2":
                    return AuthType.Oauth2;
            }
            throw new Exception("Cannot unmarshal type AuthType");
        }

        public override void Write(Utf8JsonWriter writer, AuthType value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case AuthType.Apikey:
                    JsonSerializer.Serialize(writer, "apikey", options);
                    return;
                case AuthType.Awsv4:
                    JsonSerializer.Serialize(writer, "awsv4", options);
                    return;
                case AuthType.Basic:
                    JsonSerializer.Serialize(writer, "basic", options);
                    return;
                case AuthType.Bearer:
                    JsonSerializer.Serialize(writer, "bearer", options);
                    return;
                case AuthType.Digest:
                    JsonSerializer.Serialize(writer, "digest", options);
                    return;
                case AuthType.Edgegrid:
                    JsonSerializer.Serialize(writer, "edgegrid", options);
                    return;
                case AuthType.Hawk:
                    JsonSerializer.Serialize(writer, "hawk", options);
                    return;
                case AuthType.Noauth:
                    JsonSerializer.Serialize(writer, "noauth", options);
                    return;
                case AuthType.Ntlm:
                    JsonSerializer.Serialize(writer, "ntlm", options);
                    return;
                case AuthType.Oauth1:
                    JsonSerializer.Serialize(writer, "oauth1", options);
                    return;
                case AuthType.Oauth2:
                    JsonSerializer.Serialize(writer, "oauth2", options);
                    return;
            }
            throw new Exception("Cannot marshal type AuthType");
        }

        public static readonly AuthTypeConverter Singleton = new AuthTypeConverter();
    }

    internal class HostConverter : JsonConverter<Host>
    {
        public override bool CanConvert(Type t) => t == typeof(Host);

        public override Host Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new Host { String = stringValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<string[]>(ref reader, options);
                    return new Host { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Host");
        }

        public override void Write(Utf8JsonWriter writer, Host value, JsonSerializerOptions options)
        {
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.StringArray != null)
            {
                JsonSerializer.Serialize(writer, value.StringArray, options);
                return;
            }
            throw new Exception("Cannot marshal type Host");
        }

        public static readonly HostConverter Singleton = new HostConverter();
    }

    internal class UrlConverter : JsonConverter<Url>
    {
        public override bool CanConvert(Type t) => t == typeof(Url);

        public override Url Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new Url { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<UrlClass>(ref reader, options);
                    return new Url { UrlClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type Url");
        }

        public override void Write(Utf8JsonWriter writer, Url value, JsonSerializerOptions options)
        {
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.UrlClass != null)
            {
                JsonSerializer.Serialize(writer, value.UrlClass, options);
                return;
            }
            throw new Exception("Cannot marshal type Url");
        }

        public static readonly UrlConverter Singleton = new UrlConverter();
    }

    internal class UrlPathConverter : JsonConverter<UrlPath>
    {
        public override bool CanConvert(Type t) => t == typeof(UrlPath);

        public override UrlPath Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new UrlPath { String = stringValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<PathElement[]>(ref reader, options);
                    return new UrlPath { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type UrlPath");
        }

        public override void Write(Utf8JsonWriter writer, UrlPath value, JsonSerializerOptions options)
        {
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AnythingArray != null)
            {
                JsonSerializer.Serialize(writer, value.AnythingArray, options);
                return;
            }
            throw new Exception("Cannot marshal type UrlPath");
        }

        public static readonly UrlPathConverter Singleton = new UrlPathConverter();
    }

    internal class PathElementConverter : JsonConverter<PathElement>
    {
        public override bool CanConvert(Type t) => t == typeof(PathElement);

        public override PathElement Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new PathElement { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<PathClass>(ref reader, options);
                    return new PathElement { PathClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type PathElement");
        }

        public override void Write(Utf8JsonWriter writer, PathElement value, JsonSerializerOptions options)
        {
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.PathClass != null)
            {
                JsonSerializer.Serialize(writer, value.PathClass, options);
                return;
            }
            throw new Exception("Cannot marshal type PathElement");
        }

        public static readonly PathElementConverter Singleton = new PathElementConverter();
    }

    internal class DescriptionUnionConverter : JsonConverter<DescriptionUnion>
    {
        public override bool CanConvert(Type t) => t == typeof(DescriptionUnion);

        public override DescriptionUnion Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new DescriptionUnion { };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new DescriptionUnion { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<Description>(ref reader, options);
                    return new DescriptionUnion { Description = objectValue };
            }
            throw new Exception("Cannot unmarshal type DescriptionUnion");
        }

        public override void Write(Utf8JsonWriter writer, DescriptionUnion value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.Description != null)
            {
                JsonSerializer.Serialize(writer, value.Description, options);
                return;
            }
            throw new Exception("Cannot marshal type DescriptionUnion");
        }

        public static readonly DescriptionUnionConverter Singleton = new DescriptionUnionConverter();
    }

    internal class VariableTypeConverter : JsonConverter<VariableType>
    {
        public override bool CanConvert(Type t) => t == typeof(VariableType);

        public override VariableType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "any":
                    return VariableType.Any;
                case "boolean":
                    return VariableType.Boolean;
                case "number":
                    return VariableType.Number;
                case "string":
                    return VariableType.String;
            }
            throw new Exception("Cannot unmarshal type VariableType");
        }

        public override void Write(Utf8JsonWriter writer, VariableType value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case VariableType.Any:
                    JsonSerializer.Serialize(writer, "any", options);
                    return;
                case VariableType.Boolean:
                    JsonSerializer.Serialize(writer, "boolean", options);
                    return;
                case VariableType.Number:
                    JsonSerializer.Serialize(writer, "number", options);
                    return;
                case VariableType.String:
                    JsonSerializer.Serialize(writer, "string", options);
                    return;
            }
            throw new Exception("Cannot marshal type VariableType");
        }

        public static readonly VariableTypeConverter Singleton = new VariableTypeConverter();
    }

    internal class DatumTypeConverter : JsonConverter<DatumType>
    {
        public override bool CanConvert(Type t) => t == typeof(DatumType);

        public override DatumType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "file":
                    return DatumType.File;
                case "text":
                    return DatumType.Text;
            }
            throw new Exception("Cannot unmarshal type DatumType");
        }

        public override void Write(Utf8JsonWriter writer, DatumType value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case DatumType.File:
                    JsonSerializer.Serialize(writer, "file", options);
                    return;
                case DatumType.Text:
                    JsonSerializer.Serialize(writer, "text", options);
                    return;
            }
            throw new Exception("Cannot marshal type DatumType");
        }

        public static readonly DatumTypeConverter Singleton = new DatumTypeConverter();
    }

    internal class ValueConverter : JsonConverter<Value>
    {
        public override bool CanConvert(Type t) => t == typeof(Value);

        public override Value Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new Value { };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new Value { String = stringValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<object[]>(ref reader, options);
                    return new Value { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Value");
        }

        public override void Write(Utf8JsonWriter writer, Value value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AnythingArray != null)
            {
                JsonSerializer.Serialize(writer, value.AnythingArray, options);
                return;
            }
            throw new Exception("Cannot marshal type Value");
        }

        public static readonly ValueConverter Singleton = new ValueConverter();
    }

    internal class DataModeConverter : JsonConverter<DataMode>
    {
        public override bool CanConvert(Type t) => t == typeof(DataMode);

        public override DataMode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "binary":
                    return DataMode.Binary;
                case "graphql":
                    return DataMode.Graphql;
                case "params":
                    return DataMode.Params;
                case "raw":
                    return DataMode.Raw;
                case "urlencoded":
                    return DataMode.Urlencoded;
            }
            throw new Exception("Cannot unmarshal type DataMode");
        }

        public override void Write(Utf8JsonWriter writer, DataMode value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case DataMode.Binary:
                    JsonSerializer.Serialize(writer, "binary", options);
                    return;
                case DataMode.Graphql:
                    JsonSerializer.Serialize(writer, "graphql", options);
                    return;
                case DataMode.Params:
                    JsonSerializer.Serialize(writer, "params", options);
                    return;
                case DataMode.Raw:
                    JsonSerializer.Serialize(writer, "raw", options);
                    return;
                case DataMode.Urlencoded:
                    JsonSerializer.Serialize(writer, "urlencoded", options);
                    return;
            }
            throw new Exception("Cannot marshal type DataMode");
        }

        public static readonly DataModeConverter Singleton = new DataModeConverter();
    }

    internal class DescriptionFormatConverter : JsonConverter<DescriptionFormat>
    {
        public override bool CanConvert(Type t) => t == typeof(DescriptionFormat);

        public override DescriptionFormat Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "html":
                    return DescriptionFormat.Html;
                case "markdown":
                    return DescriptionFormat.Markdown;
            }
            throw new Exception("Cannot unmarshal type DescriptionFormat");
        }

        public override void Write(Utf8JsonWriter writer, DescriptionFormat value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case DescriptionFormat.Html:
                    JsonSerializer.Serialize(writer, "html", options);
                    return;
                case DescriptionFormat.Markdown:
                    JsonSerializer.Serialize(writer, "markdown", options);
                    return;
            }
            throw new Exception("Cannot marshal type DescriptionFormat");
        }

        public static readonly DescriptionFormatConverter Singleton = new DescriptionFormatConverter();
    }

    internal class HeaderConverter : JsonConverter<Header>
    {
        public override bool CanConvert(Type t) => t == typeof(Header);

        public override Header Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new Header { };
                case JsonTokenType.Number:
                    if (reader.TryGetInt64(out var integerValue))
                        return new Header {Integer = integerValue};
                    else
                        return new Header {Double = reader.GetDouble()};
                case JsonTokenType.True:
                case JsonTokenType.False:
                    var boolValue = reader.GetBoolean();
                    return new Header { Bool = boolValue };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new Header { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<HeaderClass>(ref reader, options);
                    return new Header { HeaderClass = objectValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<object[]>(ref reader, options);
                    return new Header { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Header");
        }

        public override void Write(Utf8JsonWriter writer, Header value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.Integer != null)
            {
                JsonSerializer.Serialize(writer, value.Integer.Value, options);
                return;
            }
            if (value.Double != null)
            {
                JsonSerializer.Serialize(writer, value.Double.Value, options);
                return;
            }
            if (value.Bool != null)
            {
                JsonSerializer.Serialize(writer, value.Bool.Value, options);
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AnythingArray != null)
            {
                JsonSerializer.Serialize(writer, value.AnythingArray, options);
                return;
            }
            if (value.HeaderClass != null)
            {
                JsonSerializer.Serialize(writer, value.HeaderClass, options);
                return;
            }
            throw new Exception("Cannot marshal type Header");
        }

        public static readonly HeaderConverter Singleton = new HeaderConverter();
    }

    internal class HelperAttributesConverter : JsonConverter<HelperAttributes>
    {
        public override bool CanConvert(Type t) => t == typeof(HelperAttributes);

        public override HelperAttributes Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new HelperAttributes { };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new HelperAttributes { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<ApiKeyAuthentication>(ref reader, options);
                    return new HelperAttributes { ApiKeyAuthentication = objectValue };
            }
            throw new Exception("Cannot unmarshal type HelperAttributes");
        }

        public override void Write(Utf8JsonWriter writer, HelperAttributes value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.ApiKeyAuthentication != null)
            {
                JsonSerializer.Serialize(writer, value.ApiKeyAuthentication, options);
                return;
            }
            throw new Exception("Cannot marshal type HelperAttributes");
        }

        public static readonly HelperAttributesConverter Singleton = new HelperAttributesConverter();
    }

    internal class IdConverter : JsonConverter<Id>
    {
        public override bool CanConvert(Type t) => t == typeof(Id);

        public override Id Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "apikey":
                    return Id.Apikey;
                case "awsSigV4":
                    return Id.AwsSigV4;
                case "basic":
                    return Id.Basic;
                case "bearer":
                    return Id.Bearer;
                case "digest":
                    return Id.Digest;
                case "edgegrid":
                    return Id.Edgegrid;
                case "hawk":
                    return Id.Hawk;
                case "ntlm":
                    return Id.Ntlm;
                case "oAuth1":
                    return Id.OAuth1;
                case "oAuth2":
                    return Id.OAuth2;
            }
            throw new Exception("Cannot unmarshal type Id");
        }

        public override void Write(Utf8JsonWriter writer, Id value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case Id.Apikey:
                    JsonSerializer.Serialize(writer, "apikey", options);
                    return;
                case Id.AwsSigV4:
                    JsonSerializer.Serialize(writer, "awsSigV4", options);
                    return;
                case Id.Basic:
                    JsonSerializer.Serialize(writer, "basic", options);
                    return;
                case Id.Bearer:
                    JsonSerializer.Serialize(writer, "bearer", options);
                    return;
                case Id.Digest:
                    JsonSerializer.Serialize(writer, "digest", options);
                    return;
                case Id.Edgegrid:
                    JsonSerializer.Serialize(writer, "edgegrid", options);
                    return;
                case Id.Hawk:
                    JsonSerializer.Serialize(writer, "hawk", options);
                    return;
                case Id.Ntlm:
                    JsonSerializer.Serialize(writer, "ntlm", options);
                    return;
                case Id.OAuth1:
                    JsonSerializer.Serialize(writer, "oAuth1", options);
                    return;
                case Id.OAuth2:
                    JsonSerializer.Serialize(writer, "oAuth2", options);
                    return;
            }
            throw new Exception("Cannot marshal type Id");
        }

        public static readonly IdConverter Singleton = new IdConverter();
    }

    internal class PathVariableConverter : JsonConverter<PathVariable>
    {
        public override bool CanConvert(Type t) => t == typeof(PathVariable);

        public override PathVariable Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new PathVariable { };
                case JsonTokenType.Number:
                    if (reader.TryGetInt64(out var integerValue))
                        return new PathVariable {Integer = integerValue};
                    else
                        return new PathVariable { Double = reader.GetDouble() };
                case JsonTokenType.True:
                case JsonTokenType.False:
                    var boolValue = reader.GetBoolean();
                    return new PathVariable { Bool = boolValue };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new PathVariable { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<PathVariableClass>(ref reader, options);
                    return new PathVariable { PathVariableClass = objectValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<object[]>(ref reader, options);
                    return new PathVariable { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type PathVariable");
        }

        public override void Write(Utf8JsonWriter writer, PathVariable value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.Integer != null)
            {
                JsonSerializer.Serialize(writer, value.Integer.Value, options);
                return;
            }
            if (value.Double != null)
            {
                JsonSerializer.Serialize(writer, value.Double.Value, options);
                return;
            }
            if (value.Bool != null)
            {
                JsonSerializer.Serialize(writer, value.Bool.Value, options);
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AnythingArray != null)
            {
                JsonSerializer.Serialize(writer, value.AnythingArray, options);
                return;
            }
            if (value.PathVariableClass != null)
            {
                JsonSerializer.Serialize(writer, value.PathVariableClass, options);
                return;
            }
            throw new Exception("Cannot marshal type PathVariable");
        }

        public static readonly PathVariableConverter Singleton = new PathVariableConverter();
    }

    internal class PathVariablesConverter : JsonConverter<PathVariables>
    {
        public override bool CanConvert(Type t) => t == typeof(PathVariables);

        public override PathVariables Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new PathVariables { };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new PathVariables { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<Dictionary<string, object>>(ref reader, options);
                    return new PathVariables { AnythingMap = objectValue };
            }
            throw new Exception("Cannot unmarshal type PathVariables");
        }

        public override void Write(Utf8JsonWriter writer, PathVariables value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AnythingMap != null)
            {
                JsonSerializer.Serialize(writer, value.AnythingMap, options);
                return;
            }
            throw new Exception("Cannot marshal type PathVariables");
        }

        public static readonly PathVariablesConverter Singleton = new PathVariablesConverter();
    }

    internal class UrlParamConverter : JsonConverter<UrlParam>
    {
        public override bool CanConvert(Type t) => t == typeof(UrlParam);

        public override UrlParam Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new UrlParam { };
                case JsonTokenType.Number:
                    if (reader.TryGetInt64(out var integerValue))
                        return new UrlParam {Integer = integerValue};
                    else
                        return new UrlParam { Double = reader.GetDouble() };
                case JsonTokenType.True:
                case JsonTokenType.False:
                    var boolValue = reader.GetBoolean();
                    return new UrlParam { Bool = boolValue };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new UrlParam { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<UrlParamClass>(ref reader, options);
                    return new UrlParam { UrlParamClass = objectValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<object[]>(ref reader, options);
                    return new UrlParam { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type UrlParam");
        }

        public override void Write(Utf8JsonWriter writer, UrlParam value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.Integer != null)
            {
                JsonSerializer.Serialize(writer, value.Integer.Value, options);
                return;
            }
            if (value.Double != null)
            {
                JsonSerializer.Serialize(writer, value.Double.Value, options);
                return;
            }
            if (value.Bool != null)
            {
                JsonSerializer.Serialize(writer, value.Bool.Value, options);
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AnythingArray != null)
            {
                JsonSerializer.Serialize(writer, value.AnythingArray, options);
                return;
            }
            if (value.UrlParamClass != null)
            {
                JsonSerializer.Serialize(writer, value.UrlParamClass, options);
                return;
            }
            throw new Exception("Cannot marshal type UrlParam");
        }

        public static readonly UrlParamConverter Singleton = new UrlParamConverter();
    }

    internal class ResponseConverter : JsonConverter<Response>
    {
        public override bool CanConvert(Type t) => t == typeof(Response);

        public override Response Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new Response { };
                case JsonTokenType.Number:
                    if (reader.TryGetInt64(out var integerValue))
                        return new Response {Integer = integerValue};
                    else
                        return new Response { Double = reader.GetDouble() };
                case JsonTokenType.True:
                case JsonTokenType.False:
                    var boolValue = reader.GetBoolean();
                    return new Response { Bool = boolValue };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new Response { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<ResponseClass>(ref reader, options);
                    return new Response { ResponseClass = objectValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<object[]>(ref reader, options);
                    return new Response { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Response");
        }

        public override void Write(Utf8JsonWriter writer, Response value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.Integer != null)
            {
                JsonSerializer.Serialize(writer, value.Integer.Value, options);
                return;
            }
            if (value.Double != null)
            {
                JsonSerializer.Serialize(writer, value.Double.Value, options);
                return;
            }
            if (value.Bool != null)
            {
                JsonSerializer.Serialize(writer, value.Bool.Value, options);
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AnythingArray != null)
            {
                JsonSerializer.Serialize(writer, value.AnythingArray, options);
                return;
            }
            if (value.ResponseClass != null)
            {
                JsonSerializer.Serialize(writer, value.ResponseClass, options);
                return;
            }
            throw new Exception("Cannot marshal type Response");
        }

        public static readonly ResponseConverter Singleton = new ResponseConverter();
    }

    internal class LanguageConverter : JsonConverter<Language>
    {
        public override bool CanConvert(Type t) => t == typeof(Language);

        public override Language Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "Text":
                    return Language.Text;
                case "html":
                    return Language.Html;
                case "javascript":
                    return Language.Javascript;
                case "xml":
                    return Language.Xml;
            }
            throw new Exception("Cannot unmarshal type Language");
        }

        public override void Write(Utf8JsonWriter writer, Language value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case Language.Text:
                    JsonSerializer.Serialize(writer, "Text", options);
                    return;
                case Language.Html:
                    JsonSerializer.Serialize(writer, "html", options);
                    return;
                case Language.Javascript:
                    JsonSerializer.Serialize(writer, "javascript", options);
                    return;
                case Language.Xml:
                    JsonSerializer.Serialize(writer, "xml", options);
                    return;
            }
            throw new Exception("Cannot marshal type Language");
        }

        public static readonly LanguageConverter Singleton = new LanguageConverter();
    }

    internal class TimeConverter : JsonConverter<Time>
    {
        public override bool CanConvert(Type t) => t == typeof(Time);

        public override Time Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new Time { };
                case JsonTokenType.Number:
                    var doubleValue = reader.GetDouble();
                    return new Time { Double = doubleValue };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new Time { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type Time");
        }

        public override void Write(Utf8JsonWriter writer, Time value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.Double != null)
            {
                JsonSerializer.Serialize(writer, value.Double.Value, options);
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            throw new Exception("Cannot marshal type Time");
        }

        public static readonly TimeConverter Singleton = new TimeConverter();
    }
    
    public class DateOnlyConverter : JsonConverter<DateOnly>
    {
        private readonly string serializationFormat;
        public DateOnlyConverter() : this(null) { }

        public DateOnlyConverter(string? serializationFormat)
        {
            this.serializationFormat = serializationFormat ?? "yyyy-MM-dd";
        }

        public override DateOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            return DateOnly.Parse(value!);
        }

        public override void Write(Utf8JsonWriter writer, DateOnly value, JsonSerializerOptions options)
            => writer.WriteStringValue(value.ToString(serializationFormat));
    }

    public class TimeOnlyConverter : JsonConverter<TimeOnly>
    {
        private readonly string serializationFormat;

        public TimeOnlyConverter() : this(null) { }

        public TimeOnlyConverter(string? serializationFormat)
        {
            this.serializationFormat = serializationFormat ?? "HH:mm:ss.fff";
        }

        public override TimeOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            return TimeOnly.Parse(value!);
        }

        public override void Write(Utf8JsonWriter writer, TimeOnly value, JsonSerializerOptions options)
            => writer.WriteStringValue(value.ToString(serializationFormat));
    }

    internal class IsoDateTimeOffsetConverter : JsonConverter<DateTimeOffset>
    {
        public override bool CanConvert(Type t) => t == typeof(DateTimeOffset);

        private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

        private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;
        private string? _dateTimeFormat;
        private CultureInfo? _culture;

        public DateTimeStyles DateTimeStyles
        {
            get => _dateTimeStyles;
            set => _dateTimeStyles = value;
        }

        public string? DateTimeFormat
        {
            get => _dateTimeFormat ?? string.Empty;
            set => _dateTimeFormat = (string.IsNullOrEmpty(value)) ? null : value;
        }

        public CultureInfo Culture
        {
            get => _culture ?? CultureInfo.CurrentCulture;
            set => _culture = value;
        }

        public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
        {
            string text;


            if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal
                || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
            {
                value = value.ToUniversalTime();
            }

            text = value.ToString(_dateTimeFormat ?? DefaultDateTimeFormat, Culture);

            writer.WriteStringValue(text);
        }

        public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            string? dateText = reader.GetString();

            if (string.IsNullOrEmpty(dateText) == false)
            {
                if (!string.IsNullOrEmpty(_dateTimeFormat))
                {
                    return DateTimeOffset.ParseExact(dateText, _dateTimeFormat, Culture, _dateTimeStyles);
                }
                else
                {
                    return DateTimeOffset.Parse(dateText, Culture, _dateTimeStyles);
                }
            }
            else
            {
                return default(DateTimeOffset);
            }
        }


        public static readonly IsoDateTimeOffsetConverter Singleton = new IsoDateTimeOffsetConverter();
    }
}
#pragma warning restore CS8618
#pragma warning restore CS8601
#pragma warning restore CS8603
#pragma warning restore CS1591
