// <auto-generated />

#nullable enable
#pragma warning disable CS8618
#pragma warning disable CS8601
#pragma warning disable CS8603
#pragma warning disable CS1591

namespace HamedStack.PostmanCollectionV2_0_0
{
    using System;
    using System.Collections.Generic;

    using System.Text.Json;
    using System.Text.Json.Serialization;
    using System.Globalization;

    public partial class PostmanCollection2_0_0
    {
        [JsonPropertyName("auth")]
        public Auth Auth { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("event")]
        public Event[] Event { get; set; }

        [JsonPropertyName("info")]
        public Information Info { get; set; }

        /// <summary>
        /// Items are the basic unit for a Postman collection. You can think of them as corresponding
        /// to a single API endpoint. Each Item has one request and may have multiple API responses
        /// associated with it.
        /// </summary>
        [JsonPropertyName("item")]
        public Items[] Item { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("protocolProfileBehavior")]
        public Dictionary<string, object> ProtocolProfileBehavior { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("variable")]
        public Variable[] Variable { get; set; }
    }

    /// <summary>
    /// Represents authentication helpers provided by Postman
    /// </summary>
    public partial class Auth
    {
        /// <summary>
        /// The attributes for API Key Authentication. e.g. key, value, in.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("apikey")]
        public Dictionary<string, object> Apikey { get; set; }

        /// <summary>
        /// The attributes for [AWS
        /// Auth](http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html). e.g.
        /// accessKey, secretKey, region, service.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("awsv4")]
        public Dictionary<string, object> Awsv4 { get; set; }

        /// <summary>
        /// The attributes for [Basic
        /// Authentication](https://en.wikipedia.org/wiki/Basic_access_authentication). e.g.
        /// username, password.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("basic")]
        public Dictionary<string, object> Basic { get; set; }

        /// <summary>
        /// The attributes for [Bearer Token Authentication](https://tools.ietf.org/html/rfc6750).
        /// e.g. token.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("bearer")]
        public Dictionary<string, object> Bearer { get; set; }

        /// <summary>
        /// The attributes for [Digest
        /// Authentication](https://en.wikipedia.org/wiki/Digest_access_authentication). e.g.
        /// username, password, realm, nonce, nonceCount, algorithm, qop, opaque, clientNonce.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("digest")]
        public Dictionary<string, object> Digest { get; set; }

        /// <summary>
        /// The attributes for [Akamai EdgeGrid
        /// Authentication](https://developer.akamai.com/legacy/introduction/Client_Auth.html). e.g.
        /// accessToken, clientToken, clientSecret, baseURL, nonce, timestamp, headersToSign.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("edgegrid")]
        public Dictionary<string, object> Edgegrid { get; set; }

        /// <summary>
        /// The attributes for [Hawk Authentication](https://github.com/hueniverse/hawk). e.g.
        /// authId, authKey, algorith, user, nonce, extraData, appId, delegation, timestamp.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("hawk")]
        public Dictionary<string, object> Hawk { get; set; }

        [JsonPropertyName("noauth")]
        public object Noauth { get; set; }

        /// <summary>
        /// The attributes for [NTLM
        /// Authentication](https://msdn.microsoft.com/en-us/library/cc237488.aspx). e.g. username,
        /// password, domain, workstation.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("ntlm")]
        public Dictionary<string, object> Ntlm { get; set; }

        /// <summary>
        /// The attributes for [OAuth1](https://oauth.net/1/). e.g. consumerKey, consumerSecret,
        /// token, tokenSecret, signatureMethod, timestamp, nonce, version, realm, encodeOAuthSign.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("oauth1")]
        public Dictionary<string, object> Oauth1 { get; set; }

        /// <summary>
        /// The attributes for [OAuth2](https://oauth.net/2/). e.g. accessToken, addTokenTo.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("oauth2")]
        public Dictionary<string, object> Oauth2 { get; set; }

        [JsonPropertyName("type")]
        public AuthType Type { get; set; }
    }

    /// <summary>
    /// Postman allows you to configure scripts to run when specific events occur. These scripts
    /// are stored here, and can be referenced in the collection by their ID.
    ///
    /// Defines a script associated with an associated event name
    /// </summary>
    public partial class Event
    {
        /// <summary>
        /// Indicates whether the event is disabled. If absent, the event is assumed to be enabled.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("disabled")]
        public bool? Disabled { get; set; }

        /// <summary>
        /// A unique identifier for the enclosing event.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Can be set to `test` or `prerequest` for test scripts or pre-request scripts respectively.
        /// </summary>
        [JsonPropertyName("listen")]
        public string Listen { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("script")]
        public Script Script { get; set; }
    }

    /// <summary>
    /// A script is a snippet of Javascript code that can be used to to perform setup or teardown
    /// operations on a particular response.
    /// </summary>
    public partial class Script
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("exec")]
        public Host? Exec { get; set; }

        /// <summary>
        /// A unique, user defined identifier that can  be used to refer to this script from requests.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Script name
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("name")]
        public string Name { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("src")]
        public Url? Src { get; set; }

        /// <summary>
        /// Type of the script. E.g: 'text/javascript'
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public string Type { get; set; }
    }

    public partial class UrlClass
    {
        /// <summary>
        /// Contains the URL fragment (if any). Usually this is not transmitted over the network, but
        /// it could be useful to store this in some cases.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("hash")]
        public string Hash { get; set; }

        /// <summary>
        /// The host for the URL, E.g: api.yourdomain.com. Can be stored as a string or as an array
        /// of strings.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("host")]
        public Host? Host { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("path")]
        public UrlPath? Path { get; set; }

        /// <summary>
        /// The port number present in this URL. An empty value implies 80/443 depending on whether
        /// the protocol field contains http/https.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("port")]
        public string Port { get; set; }

        /// <summary>
        /// The protocol associated with the request, E.g: 'http'
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("protocol")]
        public string Protocol { get; set; }

        /// <summary>
        /// An array of QueryParams, which is basically the query string part of the URL, parsed into
        /// separate variables
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("query")]
        public QueryParam[] Query { get; set; }

        /// <summary>
        /// The string representation of the request URL, including the protocol, host, path, hash,
        /// query parameter(s) and path variable(s).
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("raw")]
        public string Raw { get; set; }

        /// <summary>
        /// Postman supports path variables with the syntax `/path/:variableName/to/somewhere`. These
        /// variables are stored in this field.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("variable")]
        public Variable[] Variable { get; set; }
    }

    public partial class PathClass
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public string Type { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("value")]
        public string Value { get; set; }
    }

    public partial class QueryParam
    {
        [JsonPropertyName("description")]
        public DescriptionUnion? Description { get; set; }

        /// <summary>
        /// If set to true, the current query parameter will not be sent with the request.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("disabled")]
        public bool? Disabled { get; set; }

        [JsonPropertyName("key")]
        public string Key { get; set; }

        [JsonPropertyName("value")]
        public string Value { get; set; }
    }

    public partial class Description
    {
        /// <summary>
        /// The content of the description goes here, as a raw string.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("content")]
        public string Content { get; set; }

        /// <summary>
        /// Holds the mime type of the raw description content. E.g: 'text/markdown' or 'text/html'.
        /// The type is used to correctly render the description when generating documentation, or in
        /// the Postman app.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public string Type { get; set; }

        /// <summary>
        /// Description can have versions associated with it, which should be put in this property.
        /// </summary>
        [JsonPropertyName("version")]
        public object Version { get; set; }
    }

    /// <summary>
    /// Collection variables allow you to define a set of variables, that are a *part of the
    /// collection*, as opposed to environments, which are separate entities.
    /// *Note: Collection variables must not contain any sensitive information.*
    ///
    /// Using variables in your Postman requests eliminates the need to duplicate requests, which
    /// can save a lot of time. Variables can be defined, and referenced to from any part of a
    /// request.
    /// </summary>
    public partial class Variable
    {
        [JsonPropertyName("description")]
        public DescriptionUnion? Description { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("disabled")]
        public bool? Disabled { get; set; }

        /// <summary>
        /// A variable ID is a unique user-defined value that identifies the variable within a
        /// collection. In traditional terms, this would be a variable name.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// A variable key is a human friendly value that identifies the variable within a
        /// collection. In traditional terms, this would be a variable name.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("key")]
        public string Key { get; set; }

        /// <summary>
        /// Variable name
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// When set to true, indicates that this variable has been set by Postman
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("system")]
        public bool? System { get; set; }

        /// <summary>
        /// A variable may have multiple types. This field specifies the type of the variable.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public VariableType? Type { get; set; }

        /// <summary>
        /// The value that a variable holds in this collection. Ultimately, the variables will be
        /// replaced by this value, when say running a set of requests from a collection
        /// </summary>
        [JsonPropertyName("value")]
        public object Value { get; set; }
    }

    /// <summary>
    /// Detailed description of the info block
    /// </summary>
    public partial class Information
    {
        /// <summary>
        /// Every collection is identified by the unique value of this field. The value of this field
        /// is usually easiest to generate using a UID generator function. If you already have a
        /// collection, it is recommended that you maintain the same id since changing the id usually
        /// implies that is a different collection than it was originally.
        /// *Note: This field exists for compatibility reasons with Collection Format V1.*
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("_postman_id")]
        public string PostmanId { get; set; }

        [JsonPropertyName("description")]
        public DescriptionUnion? Description { get; set; }

        /// <summary>
        /// A collection's friendly name is defined by this field. You would want to set this field
        /// to a value that would allow you to easily identify this collection among a bunch of other
        /// collections, as such outlining its usage or content.
        /// </summary>
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// This should ideally hold a link to the Postman schema that is used to validate this
        /// collection. E.g: https://schema.getpostman.com/collection/v1
        /// </summary>
        [JsonPropertyName("schema")]
        public string Schema { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("version")]
        public CollectionVersion? Version { get; set; }
    }

    public partial class CollectionVersionClass
    {
        /// <summary>
        /// A human friendly identifier to make sense of the version numbers. E.g: 'beta-3'
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("identifier")]
        [JsonConverter(typeof(MinMaxLengthCheckConverter))]
        public string Identifier { get; set; }

        /// <summary>
        /// Increment this number if you make changes to the collection that changes its behaviour.
        /// E.g: Removing or adding new test scripts. (partly or completely).
        /// </summary>
        [JsonPropertyName("major")]
        public long Major { get; set; }

        [JsonPropertyName("meta")]
        public object Meta { get; set; }

        /// <summary>
        /// You should increment this number if you make changes that will not break anything that
        /// uses the collection. E.g: removing a folder.
        /// </summary>
        [JsonPropertyName("minor")]
        public long Minor { get; set; }

        /// <summary>
        /// Ideally, minor changes to a collection should result in the increment of this number.
        /// </summary>
        [JsonPropertyName("patch")]
        public long Patch { get; set; }
    }

    /// <summary>
    /// Items are entities which contain an actual HTTP request, and sample responses attached to
    /// it.
    ///
    /// One of the primary goals of Postman is to organize the development of APIs. To this end,
    /// it is necessary to be able to group requests together. This can be achived using
    /// 'Folders'. A folder just is an ordered set of requests.
    /// </summary>
    public partial class Items
    {
        [JsonPropertyName("description")]
        public DescriptionUnion? Description { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("event")]
        public Event[] Event { get; set; }

        /// <summary>
        /// A unique ID that is used to identify collections internally
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// A human readable identifier for the current item.
        ///
        /// A folder's friendly name is defined by this field. You would want to set this field to a
        /// value that would allow you to easily identify this folder.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("name")]
        public string Name { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("protocolProfileBehavior")]
        public Dictionary<string, object> ProtocolProfileBehavior { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("request")]
        public RequestUnion? Request { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("response")]
        public Response[] Response { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("variable")]
        public Variable[] Variable { get; set; }

        [JsonPropertyName("auth")]
        public Auth Auth { get; set; }

        /// <summary>
        /// Items are entities which contain an actual HTTP request, and sample responses attached to
        /// it. Folders may contain many items.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("item")]
        public Items[] Item { get; set; }
    }

    public partial class RequestClass
    {
        [JsonPropertyName("auth")]
        public Auth Auth { get; set; }

        [JsonPropertyName("body")]
        public Body Body { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("certificate")]
        public Certificate Certificate { get; set; }

        [JsonPropertyName("description")]
        public DescriptionUnion? Description { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("header")]
        public HeaderUnion? Header { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("method")]
        public string Method { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("proxy")]
        public ProxyConfig Proxy { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("url")]
        public Url? Url { get; set; }
    }

    /// <summary>
    /// This field contains the data usually contained in the request body.
    /// </summary>
    public partial class Body
    {
        /// <summary>
        /// When set to true, prevents request body from being sent.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("disabled")]
        public bool? Disabled { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("file")]
        public File File { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("formdata")]
        public FormParameter[] Formdata { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("graphql")]
        public Dictionary<string, object> Graphql { get; set; }

        /// <summary>
        /// Postman stores the type of data associated with this request in this field.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("mode")]
        public Mode? Mode { get; set; }

        /// <summary>
        /// Additional configurations and options set for various body modes.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("options")]
        public Dictionary<string, object> Options { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("raw")]
        public string Raw { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("urlencoded")]
        public UrlEncodedParameter[] Urlencoded { get; set; }
    }

    public partial class File
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("content")]
        public string Content { get; set; }

        [JsonPropertyName("src")]
        public string Src { get; set; }
    }

    public partial class FormParameter
    {
        /// <summary>
        /// Override Content-Type header of this form data entity.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("contentType")]
        public string ContentType { get; set; }

        [JsonPropertyName("description")]
        public DescriptionUnion? Description { get; set; }

        /// <summary>
        /// When set to true, prevents this form data entity from being sent.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("disabled")]
        public bool? Disabled { get; set; }

        [JsonPropertyName("key")]
        public string Key { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public FormParameterType? Type { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("value")]
        public string Value { get; set; }

        [JsonPropertyName("src")]
        public Src? Src { get; set; }
    }

    public partial class UrlEncodedParameter
    {
        [JsonPropertyName("description")]
        public DescriptionUnion? Description { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("disabled")]
        public bool? Disabled { get; set; }

        [JsonPropertyName("key")]
        public string Key { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("value")]
        public string Value { get; set; }
    }

    /// <summary>
    /// A representation of an ssl certificate
    /// </summary>
    public partial class Certificate
    {
        /// <summary>
        /// An object containing path to file certificate, on the file system
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("cert")]
        public Cert Cert { get; set; }

        /// <summary>
        /// An object containing path to file containing private key, on the file system
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("key")]
        public Key Key { get; set; }

        /// <summary>
        /// A list of Url match pattern strings, to identify Urls this certificate can be used for.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("matches")]
        public string[] Matches { get; set; }

        /// <summary>
        /// A name for the certificate for user reference
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// The passphrase for the certificate
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("passphrase")]
        public string Passphrase { get; set; }
    }

    /// <summary>
    /// An object containing path to file certificate, on the file system
    /// </summary>
    public partial class Cert
    {
        /// <summary>
        /// The path to file containing key for certificate, on the file system
        /// </summary>
        [JsonPropertyName("src")]
        public object Src { get; set; }
    }

    /// <summary>
    /// An object containing path to file containing private key, on the file system
    /// </summary>
    public partial class Key
    {
        /// <summary>
        /// The path to file containing key for certificate, on the file system
        /// </summary>
        [JsonPropertyName("src")]
        public object Src { get; set; }
    }

    /// <summary>
    /// A representation for a list of headers
    ///
    /// Represents a single HTTP Header
    /// </summary>
    public partial class Header
    {
        [JsonPropertyName("description")]
        public DescriptionUnion? Description { get; set; }

        /// <summary>
        /// If set to true, the current header will not be sent with requests.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("disabled")]
        public bool? Disabled { get; set; }

        /// <summary>
        /// This holds the LHS of the HTTP Header, e.g ``Content-Type`` or ``X-Custom-Header``
        /// </summary>
        [JsonPropertyName("key")]
        public string Key { get; set; }

        /// <summary>
        /// The value (or the RHS) of the Header is stored in this field.
        /// </summary>
        [JsonPropertyName("value")]
        public string Value { get; set; }
    }

    /// <summary>
    /// Using the Proxy, you can configure your custom proxy into the postman for particular url
    /// match
    /// </summary>
    public partial class ProxyConfig
    {
        /// <summary>
        /// When set to true, ignores this proxy configuration entity
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("disabled")]
        public bool? Disabled { get; set; }

        /// <summary>
        /// The proxy server host
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("host")]
        public string Host { get; set; }

        /// <summary>
        /// The Url match for which the proxy config is defined
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("match")]
        public string Match { get; set; }

        /// <summary>
        /// The proxy server port
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("port")]
        public long? Port { get; set; }

        /// <summary>
        /// The tunneling details for the proxy config
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("tunnel")]
        public bool? Tunnel { get; set; }
    }

    public partial class ResponseClass
    {
        /// <summary>
        /// The raw text of the response.
        /// </summary>
        [JsonPropertyName("body")]
        public string Body { get; set; }

        /// <summary>
        /// The numerical response code, example: 200, 201, 404, etc.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("code")]
        public long? Code { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("cookie")]
        public Cookie[] Cookie { get; set; }

        [JsonPropertyName("header")]
        public Headers? Header { get; set; }

        /// <summary>
        /// A unique, user defined identifier that can  be used to refer to this response from
        /// requests.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("id")]
        public string Id { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("originalRequest")]
        public RequestUnion? OriginalRequest { get; set; }

        /// <summary>
        /// The time taken by the request to complete. If a number, the unit is milliseconds. If the
        /// response is manually created, this can be set to `null`.
        /// </summary>
        [JsonPropertyName("responseTime")]
        public ResponseTime? ResponseTime { get; set; }

        /// <summary>
        /// The response status, e.g: '200 OK'
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("status")]
        public string Status { get; set; }

        /// <summary>
        /// Set of timing information related to request and response in milliseconds
        /// </summary>
        [JsonPropertyName("timings")]
        public Dictionary<string, object> Timings { get; set; }
    }

    /// <summary>
    /// A Cookie, that follows the [Google Chrome
    /// format](https://developer.chrome.com/extensions/cookies)
    /// </summary>
    public partial class Cookie
    {
        /// <summary>
        /// The domain for which this cookie is valid.
        /// </summary>
        [JsonPropertyName("domain")]
        public string Domain { get; set; }

        /// <summary>
        /// When the cookie expires.
        /// </summary>
        [JsonPropertyName("expires")]
        public string Expires { get; set; }

        /// <summary>
        /// Custom attributes for a cookie go here, such as the [Priority
        /// Field](https://code.google.com/p/chromium/issues/detail?id=232693)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("extensions")]
        public object[] Extensions { get; set; }

        /// <summary>
        /// True if the cookie is a host-only cookie. (i.e. a request's URL domain must exactly match
        /// the domain of the cookie).
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("hostOnly")]
        public bool? HostOnly { get; set; }

        /// <summary>
        /// Indicates if this cookie is HTTP Only. (if True, the cookie is inaccessible to
        /// client-side scripts)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("httpOnly")]
        public bool? HttpOnly { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("maxAge")]
        public string MaxAge { get; set; }

        /// <summary>
        /// This is the name of the Cookie.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// The path associated with the Cookie.
        /// </summary>
        [JsonPropertyName("path")]
        public string Path { get; set; }

        /// <summary>
        /// Indicates if the 'secure' flag is set on the Cookie, meaning that it is transmitted over
        /// secure connections only. (typically HTTPS)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("secure")]
        public bool? Secure { get; set; }

        /// <summary>
        /// True if the cookie is a session cookie.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("session")]
        public bool? Session { get; set; }

        /// <summary>
        /// The value of the Cookie.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("value")]
        public string Value { get; set; }
    }

    public enum AuthType { Apikey, Awsv4, Basic, Bearer, Digest, Edgegrid, Hawk, Noauth, Ntlm, Oauth1, Oauth2 };

    /// <summary>
    /// A variable may have multiple types. This field specifies the type of the variable.
    /// </summary>
    public enum VariableType { Any, Boolean, Number, String };

    public enum FormParameterType { File, Text };

    /// <summary>
    /// Postman stores the type of data associated with this request in this field.
    /// </summary>
    public enum Mode { File, Formdata, Graphql, Raw, Urlencoded };

    /// <summary>
    /// The host for the URL, E.g: api.yourdomain.com. Can be stored as a string or as an array
    /// of strings.
    /// </summary>
    public partial struct Host
    {
        public string String;
        public string[] StringArray;

        public static implicit operator Host(string String) => new Host { String = String };
        public static implicit operator Host(string[] StringArray) => new Host { StringArray = StringArray };
    }

    /// <summary>
    /// The complete path of the current url, broken down into segments. A segment could be a
    /// string, or a path variable.
    /// </summary>
    public partial struct PathElement
    {
        public PathClass PathClass;
        public string String;

        public static implicit operator PathElement(PathClass PathClass) => new PathElement { PathClass = PathClass };
        public static implicit operator PathElement(string String) => new PathElement { String = String };
    }

    public partial struct UrlPath
    {
        public PathElement[] AnythingArray;
        public string String;

        public static implicit operator UrlPath(PathElement[] AnythingArray) => new UrlPath { AnythingArray = AnythingArray };
        public static implicit operator UrlPath(string String) => new UrlPath { String = String };
    }

    /// <summary>
    /// A Description can be a raw text, or be an object, which holds the description along with
    /// its format.
    /// </summary>
    public partial struct DescriptionUnion
    {
        public Description Description;
        public string String;

        public static implicit operator DescriptionUnion(Description Description) => new DescriptionUnion { Description = Description };
        public static implicit operator DescriptionUnion(string String) => new DescriptionUnion { String = String };
        public bool IsNull => Description == null && String == null;
    }

    /// <summary>
    /// If object, contains the complete broken-down URL for this request. If string, contains
    /// the literal request URL.
    /// </summary>
    public partial struct Url
    {
        public string String;
        public UrlClass UrlClass;

        public static implicit operator Url(string String) => new Url { String = String };
        public static implicit operator Url(UrlClass UrlClass) => new Url { UrlClass = UrlClass };
    }

    /// <summary>
    /// Postman allows you to version your collections as they grow, and this field holds the
    /// version number. While optional, it is recommended that you use this field to its fullest
    /// extent!
    /// </summary>
    public partial struct CollectionVersion
    {
        public CollectionVersionClass CollectionVersionClass;
        public string String;

        public static implicit operator CollectionVersion(CollectionVersionClass CollectionVersionClass) => new CollectionVersion { CollectionVersionClass = CollectionVersionClass };
        public static implicit operator CollectionVersion(string String) => new CollectionVersion { String = String };
    }

    public partial struct Src
    {
        public object[] AnythingArray;
        public string String;

        public static implicit operator Src(object[] AnythingArray) => new Src { AnythingArray = AnythingArray };
        public static implicit operator Src(string String) => new Src { String = String };
        public bool IsNull => AnythingArray == null && String == null;
    }

    public partial struct HeaderUnion
    {
        public Header[] HeaderArray;
        public string String;

        public static implicit operator HeaderUnion(Header[] HeaderArray) => new HeaderUnion { HeaderArray = HeaderArray };
        public static implicit operator HeaderUnion(string String) => new HeaderUnion { String = String };
    }

    /// <summary>
    /// A request represents an HTTP request. If a string, the string is assumed to be the
    /// request URL and the method is assumed to be 'GET'.
    /// </summary>
    public partial struct RequestUnion
    {
        public RequestClass RequestClass;
        public string String;

        public static implicit operator RequestUnion(RequestClass RequestClass) => new RequestUnion { RequestClass = RequestClass };
        public static implicit operator RequestUnion(string String) => new RequestUnion { String = String };
    }

    /// <summary>
    /// No HTTP request is complete without its headers, and the same is true for a Postman
    /// request. This field is an array containing all the headers.
    /// </summary>
    public partial struct HeaderElement
    {
        public Header Header;
        public string String;

        public static implicit operator HeaderElement(Header Header) => new HeaderElement { Header = Header };
        public static implicit operator HeaderElement(string String) => new HeaderElement { String = String };
    }

    public partial struct Headers
    {
        public HeaderElement[] AnythingArray;
        public string String;

        public static implicit operator Headers(HeaderElement[] AnythingArray) => new Headers { AnythingArray = AnythingArray };
        public static implicit operator Headers(string String) => new Headers { String = String };
        public bool IsNull => AnythingArray == null && String == null;
    }

    /// <summary>
    /// The time taken by the request to complete. If a number, the unit is milliseconds. If the
    /// response is manually created, this can be set to `null`.
    /// </summary>
    public partial struct ResponseTime
    {
        public double? Double;
        public string String;

        public static implicit operator ResponseTime(double Double) => new ResponseTime { Double = Double };
        public static implicit operator ResponseTime(string String) => new ResponseTime { String = String };
        public bool IsNull => Double == null && String == null;
    }

    /// <summary>
    /// A response represents an HTTP response.
    /// </summary>
    public partial struct Response
    {
        public object[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public long? Integer;
        public ResponseClass ResponseClass;
        public string String;

        public static implicit operator Response(object[] AnythingArray) => new Response { AnythingArray = AnythingArray };
        public static implicit operator Response(bool Bool) => new Response { Bool = Bool };
        public static implicit operator Response(double Double) => new Response { Double = Double };
        public static implicit operator Response(long Integer) => new Response { Integer = Integer };
        public static implicit operator Response(ResponseClass ResponseClass) => new Response { ResponseClass = ResponseClass };
        public static implicit operator Response(string String) => new Response { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && ResponseClass == null && Double == null && Integer == null && String == null;
    }

    public partial class PostmanCollection2_0_0
    {
        public static PostmanCollection2_0_0 FromJson(string json) => JsonSerializer.Deserialize<PostmanCollection2_0_0>(json, PostmanCollectionV2_0_0.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this PostmanCollection2_0_0 self) => JsonSerializer.Serialize(self, PostmanCollectionV2_0_0.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerOptions Settings = new(JsonSerializerDefaults.General)
        {
            Converters =
            {
                AuthTypeConverter.Singleton,
                HostConverter.Singleton,
                UrlConverter.Singleton,
                UrlPathConverter.Singleton,
                PathElementConverter.Singleton,
                DescriptionUnionConverter.Singleton,
                VariableTypeConverter.Singleton,
                CollectionVersionConverter.Singleton,
                RequestUnionConverter.Singleton,
                SrcConverter.Singleton,
                FormParameterTypeConverter.Singleton,
                ModeConverter.Singleton,
                HeaderUnionConverter.Singleton,
                ResponseConverter.Singleton,
                HeadersConverter.Singleton,
                HeaderElementConverter.Singleton,
                ResponseTimeConverter.Singleton,
                new DateOnlyConverter(),
                new TimeOnlyConverter(),
                IsoDateTimeOffsetConverter.Singleton
            },
        };
    }

    internal class AuthTypeConverter : JsonConverter<AuthType>
    {
        public override bool CanConvert(Type t) => t == typeof(AuthType);

        public override AuthType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "apikey":
                    return AuthType.Apikey;
                case "awsv4":
                    return AuthType.Awsv4;
                case "basic":
                    return AuthType.Basic;
                case "bearer":
                    return AuthType.Bearer;
                case "digest":
                    return AuthType.Digest;
                case "edgegrid":
                    return AuthType.Edgegrid;
                case "hawk":
                    return AuthType.Hawk;
                case "noauth":
                    return AuthType.Noauth;
                case "ntlm":
                    return AuthType.Ntlm;
                case "oauth1":
                    return AuthType.Oauth1;
                case "oauth2":
                    return AuthType.Oauth2;
            }
            throw new Exception("Cannot unmarshal type AuthType");
        }

        public override void Write(Utf8JsonWriter writer, AuthType value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case AuthType.Apikey:
                    JsonSerializer.Serialize(writer, "apikey", options);
                    return;
                case AuthType.Awsv4:
                    JsonSerializer.Serialize(writer, "awsv4", options);
                    return;
                case AuthType.Basic:
                    JsonSerializer.Serialize(writer, "basic", options);
                    return;
                case AuthType.Bearer:
                    JsonSerializer.Serialize(writer, "bearer", options);
                    return;
                case AuthType.Digest:
                    JsonSerializer.Serialize(writer, "digest", options);
                    return;
                case AuthType.Edgegrid:
                    JsonSerializer.Serialize(writer, "edgegrid", options);
                    return;
                case AuthType.Hawk:
                    JsonSerializer.Serialize(writer, "hawk", options);
                    return;
                case AuthType.Noauth:
                    JsonSerializer.Serialize(writer, "noauth", options);
                    return;
                case AuthType.Ntlm:
                    JsonSerializer.Serialize(writer, "ntlm", options);
                    return;
                case AuthType.Oauth1:
                    JsonSerializer.Serialize(writer, "oauth1", options);
                    return;
                case AuthType.Oauth2:
                    JsonSerializer.Serialize(writer, "oauth2", options);
                    return;
            }
            throw new Exception("Cannot marshal type AuthType");
        }

        public static readonly AuthTypeConverter Singleton = new AuthTypeConverter();
    }

    internal class HostConverter : JsonConverter<Host>
    {
        public override bool CanConvert(Type t) => t == typeof(Host);

        public override Host Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new Host { String = stringValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<string[]>(ref reader, options);
                    return new Host { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Host");
        }

        public override void Write(Utf8JsonWriter writer, Host value, JsonSerializerOptions options)
        {
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.StringArray != null)
            {
                JsonSerializer.Serialize(writer, value.StringArray, options);
                return;
            }
            throw new Exception("Cannot marshal type Host");
        }

        public static readonly HostConverter Singleton = new HostConverter();
    }

    internal class UrlConverter : JsonConverter<Url>
    {
        public override bool CanConvert(Type t) => t == typeof(Url);

        public override Url Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new Url { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<UrlClass>(ref reader, options);
                    return new Url { UrlClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type Url");
        }

        public override void Write(Utf8JsonWriter writer, Url value, JsonSerializerOptions options)
        {
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.UrlClass != null)
            {
                JsonSerializer.Serialize(writer, value.UrlClass, options);
                return;
            }
            throw new Exception("Cannot marshal type Url");
        }

        public static readonly UrlConverter Singleton = new UrlConverter();
    }

    internal class UrlPathConverter : JsonConverter<UrlPath>
    {
        public override bool CanConvert(Type t) => t == typeof(UrlPath);

        public override UrlPath Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new UrlPath { String = stringValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<PathElement[]>(ref reader, options);
                    return new UrlPath { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type UrlPath");
        }

        public override void Write(Utf8JsonWriter writer, UrlPath value, JsonSerializerOptions options)
        {
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AnythingArray != null)
            {
                JsonSerializer.Serialize(writer, value.AnythingArray, options);
                return;
            }
            throw new Exception("Cannot marshal type UrlPath");
        }

        public static readonly UrlPathConverter Singleton = new UrlPathConverter();
    }

    internal class PathElementConverter : JsonConverter<PathElement>
    {
        public override bool CanConvert(Type t) => t == typeof(PathElement);

        public override PathElement Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new PathElement { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<PathClass>(ref reader, options);
                    return new PathElement { PathClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type PathElement");
        }

        public override void Write(Utf8JsonWriter writer, PathElement value, JsonSerializerOptions options)
        {
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.PathClass != null)
            {
                JsonSerializer.Serialize(writer, value.PathClass, options);
                return;
            }
            throw new Exception("Cannot marshal type PathElement");
        }

        public static readonly PathElementConverter Singleton = new PathElementConverter();
    }

    internal class DescriptionUnionConverter : JsonConverter<DescriptionUnion>
    {
        public override bool CanConvert(Type t) => t == typeof(DescriptionUnion);

        public override DescriptionUnion Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new DescriptionUnion { };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new DescriptionUnion { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<Description>(ref reader, options);
                    return new DescriptionUnion { Description = objectValue };
            }
            throw new Exception("Cannot unmarshal type DescriptionUnion");
        }

        public override void Write(Utf8JsonWriter writer, DescriptionUnion value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.Description != null)
            {
                JsonSerializer.Serialize(writer, value.Description, options);
                return;
            }
            throw new Exception("Cannot marshal type DescriptionUnion");
        }

        public static readonly DescriptionUnionConverter Singleton = new DescriptionUnionConverter();
    }

    internal class VariableTypeConverter : JsonConverter<VariableType>
    {
        public override bool CanConvert(Type t) => t == typeof(VariableType);

        public override VariableType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "any":
                    return VariableType.Any;
                case "boolean":
                    return VariableType.Boolean;
                case "number":
                    return VariableType.Number;
                case "string":
                    return VariableType.String;
            }
            throw new Exception("Cannot unmarshal type VariableType");
        }

        public override void Write(Utf8JsonWriter writer, VariableType value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case VariableType.Any:
                    JsonSerializer.Serialize(writer, "any", options);
                    return;
                case VariableType.Boolean:
                    JsonSerializer.Serialize(writer, "boolean", options);
                    return;
                case VariableType.Number:
                    JsonSerializer.Serialize(writer, "number", options);
                    return;
                case VariableType.String:
                    JsonSerializer.Serialize(writer, "string", options);
                    return;
            }
            throw new Exception("Cannot marshal type VariableType");
        }

        public static readonly VariableTypeConverter Singleton = new VariableTypeConverter();
    }

    internal class CollectionVersionConverter : JsonConverter<CollectionVersion>
    {
        public override bool CanConvert(Type t) => t == typeof(CollectionVersion);

        public override CollectionVersion Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new CollectionVersion { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<CollectionVersionClass>(ref reader, options);
                    return new CollectionVersion { CollectionVersionClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type CollectionVersion");
        }

        public override void Write(Utf8JsonWriter writer, CollectionVersion value, JsonSerializerOptions options)
        {
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.CollectionVersionClass != null)
            {
                JsonSerializer.Serialize(writer, value.CollectionVersionClass, options);
                return;
            }
            throw new Exception("Cannot marshal type CollectionVersion");
        }

        public static readonly CollectionVersionConverter Singleton = new CollectionVersionConverter();
    }

    internal class MinMaxLengthCheckConverter : JsonConverter<string>
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override string Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            if (value != null && value.Length <= 10)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void Write(Utf8JsonWriter writer, string value, JsonSerializerOptions options)
        {
            if (value.Length <= 10)
            {
                JsonSerializer.Serialize(writer, value, options);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly MinMaxLengthCheckConverter Singleton = new MinMaxLengthCheckConverter();
    }

    internal class RequestUnionConverter : JsonConverter<RequestUnion>
    {
        public override bool CanConvert(Type t) => t == typeof(RequestUnion);

        public override RequestUnion Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new RequestUnion { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<RequestClass>(ref reader, options);
                    return new RequestUnion { RequestClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type RequestUnion");
        }

        public override void Write(Utf8JsonWriter writer, RequestUnion value, JsonSerializerOptions options)
        {
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.RequestClass != null)
            {
                JsonSerializer.Serialize(writer, value.RequestClass, options);
                return;
            }
            throw new Exception("Cannot marshal type RequestUnion");
        }

        public static readonly RequestUnionConverter Singleton = new RequestUnionConverter();
    }

    internal class SrcConverter : JsonConverter<Src>
    {
        public override bool CanConvert(Type t) => t == typeof(Src);

        public override Src Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new Src { };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new Src { String = stringValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<object[]>(ref reader, options);
                    return new Src { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Src");
        }

        public override void Write(Utf8JsonWriter writer, Src value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AnythingArray != null)
            {
                JsonSerializer.Serialize(writer, value.AnythingArray, options);
                return;
            }
            throw new Exception("Cannot marshal type Src");
        }

        public static readonly SrcConverter Singleton = new SrcConverter();
    }

    internal class FormParameterTypeConverter : JsonConverter<FormParameterType>
    {
        public override bool CanConvert(Type t) => t == typeof(FormParameterType);

        public override FormParameterType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "file":
                    return FormParameterType.File;
                case "text":
                    return FormParameterType.Text;
            }
            throw new Exception("Cannot unmarshal type FormParameterType");
        }

        public override void Write(Utf8JsonWriter writer, FormParameterType value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case FormParameterType.File:
                    JsonSerializer.Serialize(writer, "file", options);
                    return;
                case FormParameterType.Text:
                    JsonSerializer.Serialize(writer, "text", options);
                    return;
            }
            throw new Exception("Cannot marshal type FormParameterType");
        }

        public static readonly FormParameterTypeConverter Singleton = new FormParameterTypeConverter();
    }

    internal class ModeConverter : JsonConverter<Mode>
    {
        public override bool CanConvert(Type t) => t == typeof(Mode);

        public override Mode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "file":
                    return Mode.File;
                case "formdata":
                    return Mode.Formdata;
                case "graphql":
                    return Mode.Graphql;
                case "raw":
                    return Mode.Raw;
                case "urlencoded":
                    return Mode.Urlencoded;
            }
            throw new Exception("Cannot unmarshal type Mode");
        }

        public override void Write(Utf8JsonWriter writer, Mode value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case Mode.File:
                    JsonSerializer.Serialize(writer, "file", options);
                    return;
                case Mode.Formdata:
                    JsonSerializer.Serialize(writer, "formdata", options);
                    return;
                case Mode.Graphql:
                    JsonSerializer.Serialize(writer, "graphql", options);
                    return;
                case Mode.Raw:
                    JsonSerializer.Serialize(writer, "raw", options);
                    return;
                case Mode.Urlencoded:
                    JsonSerializer.Serialize(writer, "urlencoded", options);
                    return;
            }
            throw new Exception("Cannot marshal type Mode");
        }

        public static readonly ModeConverter Singleton = new ModeConverter();
    }

    internal class HeaderUnionConverter : JsonConverter<HeaderUnion>
    {
        public override bool CanConvert(Type t) => t == typeof(HeaderUnion);

        public override HeaderUnion Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new HeaderUnion { String = stringValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<Header[]>(ref reader, options);
                    return new HeaderUnion { HeaderArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type HeaderUnion");
        }

        public override void Write(Utf8JsonWriter writer, HeaderUnion value, JsonSerializerOptions options)
        {
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.HeaderArray != null)
            {
                JsonSerializer.Serialize(writer, value.HeaderArray, options);
                return;
            }
            throw new Exception("Cannot marshal type HeaderUnion");
        }

        public static readonly HeaderUnionConverter Singleton = new HeaderUnionConverter();
    }

    internal class ResponseConverter : JsonConverter<Response>
    {
        public override bool CanConvert(Type t) => t == typeof(Response);

        public override Response Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new Response { };
                case JsonTokenType.Number:
                    if (reader.TryGetInt64(out var integerValue))
                        return new Response {Integer = integerValue};
                    else
                        return new Response { Double = reader.GetDouble() };
                case JsonTokenType.True:
                case JsonTokenType.False:
                    var boolValue = reader.GetBoolean();
                    return new Response { Bool = boolValue };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new Response { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<ResponseClass>(ref reader, options);
                    return new Response { ResponseClass = objectValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<object[]>(ref reader, options);
                    return new Response { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Response");
        }

        public override void Write(Utf8JsonWriter writer, Response value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.Integer != null)
            {
                JsonSerializer.Serialize(writer, value.Integer.Value, options);
                return;
            }
            if (value.Double != null)
            {
                JsonSerializer.Serialize(writer, value.Double.Value, options);
                return;
            }
            if (value.Bool != null)
            {
                JsonSerializer.Serialize(writer, value.Bool.Value, options);
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AnythingArray != null)
            {
                JsonSerializer.Serialize(writer, value.AnythingArray, options);
                return;
            }
            if (value.ResponseClass != null)
            {
                JsonSerializer.Serialize(writer, value.ResponseClass, options);
                return;
            }
            throw new Exception("Cannot marshal type Response");
        }

        public static readonly ResponseConverter Singleton = new ResponseConverter();
    }

    internal class HeadersConverter : JsonConverter<Headers>
    {
        public override bool CanConvert(Type t) => t == typeof(Headers);

        public override Headers Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new Headers { };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new Headers { String = stringValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<HeaderElement[]>(ref reader, options);
                    return new Headers { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Headers");
        }

        public override void Write(Utf8JsonWriter writer, Headers value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AnythingArray != null)
            {
                JsonSerializer.Serialize(writer, value.AnythingArray, options);
                return;
            }
            throw new Exception("Cannot marshal type Headers");
        }

        public static readonly HeadersConverter Singleton = new HeadersConverter();
    }

    internal class HeaderElementConverter : JsonConverter<HeaderElement>
    {
        public override bool CanConvert(Type t) => t == typeof(HeaderElement);

        public override HeaderElement Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new HeaderElement { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<Header>(ref reader, options);
                    return new HeaderElement { Header = objectValue };
            }
            throw new Exception("Cannot unmarshal type HeaderElement");
        }

        public override void Write(Utf8JsonWriter writer, HeaderElement value, JsonSerializerOptions options)
        {
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.Header != null)
            {
                JsonSerializer.Serialize(writer, value.Header, options);
                return;
            }
            throw new Exception("Cannot marshal type HeaderElement");
        }

        public static readonly HeaderElementConverter Singleton = new HeaderElementConverter();
    }

    internal class ResponseTimeConverter : JsonConverter<ResponseTime>
    {
        public override bool CanConvert(Type t) => t == typeof(ResponseTime);

        public override ResponseTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new ResponseTime { };
                case JsonTokenType.Number:
                    var doubleValue = reader.GetDouble();
                    return new ResponseTime { Double = doubleValue };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new ResponseTime { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type ResponseTime");
        }

        public override void Write(Utf8JsonWriter writer, ResponseTime value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.Double != null)
            {
                JsonSerializer.Serialize(writer, value.Double.Value, options);
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            throw new Exception("Cannot marshal type ResponseTime");
        }

        public static readonly ResponseTimeConverter Singleton = new ResponseTimeConverter();
    }
    
    public class DateOnlyConverter : JsonConverter<DateOnly>
    {
        private readonly string serializationFormat;
        public DateOnlyConverter() : this(null) { }

        public DateOnlyConverter(string? serializationFormat)
        {
            this.serializationFormat = serializationFormat ?? "yyyy-MM-dd";
        }

        public override DateOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            return DateOnly.Parse(value!);
        }

        public override void Write(Utf8JsonWriter writer, DateOnly value, JsonSerializerOptions options)
            => writer.WriteStringValue(value.ToString(serializationFormat));
    }

    public class TimeOnlyConverter : JsonConverter<TimeOnly>
    {
        private readonly string serializationFormat;

        public TimeOnlyConverter() : this(null) { }

        public TimeOnlyConverter(string? serializationFormat)
        {
            this.serializationFormat = serializationFormat ?? "HH:mm:ss.fff";
        }

        public override TimeOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            return TimeOnly.Parse(value!);
        }

        public override void Write(Utf8JsonWriter writer, TimeOnly value, JsonSerializerOptions options)
            => writer.WriteStringValue(value.ToString(serializationFormat));
    }

    internal class IsoDateTimeOffsetConverter : JsonConverter<DateTimeOffset>
    {
        public override bool CanConvert(Type t) => t == typeof(DateTimeOffset);

        private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

        private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;
        private string? _dateTimeFormat;
        private CultureInfo? _culture;

        public DateTimeStyles DateTimeStyles
        {
            get => _dateTimeStyles;
            set => _dateTimeStyles = value;
        }

        public string? DateTimeFormat
        {
            get => _dateTimeFormat ?? string.Empty;
            set => _dateTimeFormat = (string.IsNullOrEmpty(value)) ? null : value;
        }

        public CultureInfo Culture
        {
            get => _culture ?? CultureInfo.CurrentCulture;
            set => _culture = value;
        }

        public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
        {
            string text;


            if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal
                || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
            {
                value = value.ToUniversalTime();
            }

            text = value.ToString(_dateTimeFormat ?? DefaultDateTimeFormat, Culture);

            writer.WriteStringValue(text);
        }

        public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            string? dateText = reader.GetString();

            if (string.IsNullOrEmpty(dateText) == false)
            {
                if (!string.IsNullOrEmpty(_dateTimeFormat))
                {
                    return DateTimeOffset.ParseExact(dateText, _dateTimeFormat, Culture, _dateTimeStyles);
                }
                else
                {
                    return DateTimeOffset.Parse(dateText, Culture, _dateTimeStyles);
                }
            }
            else
            {
                return default(DateTimeOffset);
            }
        }
        public static readonly IsoDateTimeOffsetConverter Singleton = new IsoDateTimeOffsetConverter();
    }
}
#pragma warning restore CS8618
#pragma warning restore CS8601
#pragma warning restore CS8603
#pragma warning restore CS1591
